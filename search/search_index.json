{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p> Empowering Collaboration, Simplifying Complexity </p> <p> </p> <p>     Ceylon orchestrates AI agents to automate complex tasks through collaborative problem-solving. </p> <p>Ceylon is a distributed Multi-Agent System (MAS) built on modern P2P architecture, designed to orchestrate complex task flows among multiple AI agents. It leverages libp2p for robust peer-to-peer communication and Rust for performance-critical components.</p> <p></p>"},{"location":"index.html#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>Agent Management: Easily define and manage agents with specific roles and tools</li> <li>Task Automation: Automate task flow based on agent input and predefined sequences</li> <li>Scalability: Handle multiple agents and complex workflows with ease</li> <li>Customization: Highly adaptable to fit diverse use cases</li> <li>Distributed Architecture: Developed as a robust distributed system</li> <li>Efficient Message Propagation: Utilizes a powerful framework for reliable inter-agent communication</li> <li>Interoperability and Performance: Ensures seamless operation across different programming languages while providing memory safety and high performance</li> <li>Chief Agent Leadership: Centralized task management and execution flow</li> <li>Parallel or Sequential Execution: Adapt to your task's needs</li> <li>Customizable I/O: Define inputs and outputs tailored to your requirements</li> <li>Versatile Deployment: Run as a server or standalone application</li> </ul>"},{"location":"index.html#why-ceylon","title":"\ud83c\udf1f Why Ceylon?","text":"<p>Ceylon pushes the boundaries of what's possible in task automation and AI collaboration. It's not just another framework; it's a new paradigm for solving complex problems.</p> <ul> <li>Achieve the Impossible: Tackle tasks that traditional single-agent or monolithic systems can't handle</li> <li>Flexible Architecture: Easily adapt to various use cases, from customer support to market analysis</li> <li>Scalable Performance: Distribute workload across multiple agents for improved efficiency</li> <li>Rich Interaction: Agents share information, creating a truly collaborative AI ecosystem</li> </ul>"},{"location":"index.html#technology-stack","title":"Technology Stack","text":""},{"location":"index.html#core-infrastructure","title":"Core Infrastructure","text":"<ul> <li>Communication Layer: libp2p Rust implementation</li> <li>Runtime Environment: Async-capable Python with Rust bindings</li> <li>Message Protocol: Binary-serialized protocol buffers</li> <li>State Management: Distributed state with eventual consistency</li> </ul>"},{"location":"index.html#performance-features","title":"Performance Features","text":"<ul> <li>Zero-copy message passing</li> <li>Lock-free concurrency</li> <li>Optimized async I/O</li> <li>Minimal memory footprint</li> </ul>"},{"location":"index.html#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.8+</li> <li>Rust toolchain (for building from source)</li> <li>2GB RAM minimum</li> <li>Network connectivity for P2P communication</li> </ul>"},{"location":"index.html#contact-license","title":"Contact &amp; License","text":"<ul> <li>Support: support@ceylon.ai</li> <li>Discord: https://discord.gg/7u8qahuYMq</li> <li>License: Apache-2.0 (LICENSE)</li> </ul>"},{"location":"index.html#architecture-note","title":"Architecture Note","text":"<p>Ceylon implements a pure P2P networking solution using libp2p Rust implementation. While using similar distributed networking principles as BitTorrent, it operates independently of any blockchain technology. The system provides autonomous agent communication through a high-performance P2P network layer.</p> <p>Copyright 2024-Present, Syigen Ltd. and Syigen Private Limited. All rights reserved.</p>"},{"location":"5-minutes-to-ceylon.html","title":"Ceylon Minimal Playground Tutorial","text":""},{"location":"5-minutes-to-ceylon.html#installation","title":"Installation","text":"<p>First, install Ceylon and its dependencies:</p> <pre><code>pip install ceylon loguru\n</code></pre>"},{"location":"5-minutes-to-ceylon.html#basic-concepts","title":"Basic Concepts","text":"<p>Ceylon is a framework for building distributed systems. The minimal approach uses:</p> <ol> <li>BasePlayground: Coordinates message passing between agents</li> <li>Worker: An agent that can send and receive messages</li> <li>Message Handlers: Functions that process specific types of messages</li> </ol>"},{"location":"5-minutes-to-ceylon.html#simple-example","title":"Simple Example","text":"<p>Here's a minimal example showing the core functionality:</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\n\nfrom loguru import logger\nfrom ceylon import Worker, AgentDetail\nfrom ceylon.base.playground import BasePlayGround\n\n\n# Define a message type\n@dataclass\nclass SimpleMessage:\n    content: str\n\n\n# Create playground and agent\nplayground = BasePlayGround(name=\"minimal_demo\")\nagent = Worker(\"worker1\")\n\n\n# Define message handler\n@agent.on(SimpleMessage)\nasync def handle_message(message: SimpleMessage, sender: AgentDetail, time: int):\n    logger.info(f\"From {sender.name} received: {message.content}\")\n\n\nasync def main():\n    async with playground.play(workers=[agent]) as active_playground:\n        message = SimpleMessage(content=\"Hello from worker1!\")\n        await active_playground.broadcast_message(message)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"5-minutes-to-ceylon.html#breaking-down-the-components","title":"Breaking Down the Components","text":""},{"location":"5-minutes-to-ceylon.html#1-message-types","title":"1. Message Types","text":"<p>Messages are defined using dataclasses:</p> <pre><code>@dataclass\nclass SimpleMessage:\n    content: str\n</code></pre>"},{"location":"5-minutes-to-ceylon.html#2-playground-and-agent","title":"2. Playground and Agent","text":"<p>Create instances at module level:</p> <pre><code>playground = BasePlayGround(name=\"minimal_demo\")\nagent = Worker(\"worker1\")\n</code></pre>"},{"location":"5-minutes-to-ceylon.html#3-message-handler","title":"3. Message Handler","text":"<p>Use the <code>@agent.on</code> decorator to handle specific message types:</p> <pre><code>@agent.on(SimpleMessage)\nasync def handle_message(message: SimpleMessage, sender: AgentDetail, time: int):\n    logger.info(f\"From {sender.name} received: {message.content}\")\n</code></pre>"},{"location":"5-minutes-to-ceylon.html#4-message-broadcasting","title":"4. Message Broadcasting","text":"<p>Send messages through the playground:</p> <pre><code>await active_playground.broadcast_message(message)\n</code></pre>"},{"location":"5-minutes-to-ceylon.html#common-use-cases","title":"Common Use Cases","text":"<ol> <li> <p>System Monitoring</p> <ul> <li>Agents sending status updates</li> <li>Collecting metrics</li> </ul> </li> <li> <p>Event Processing</p> <ul> <li>Handling events in distributed systems</li> <li>Event broadcasting</li> </ul> </li> <li> <p>Simple Communication</p> <ul> <li>Message passing between components</li> <li>Basic coordination</li> </ul> </li> </ol>"},{"location":"5-minutes-to-ceylon.html#best-practices","title":"Best Practices","text":"<ol> <li> <p>Message Design</p> <ul> <li>Keep message classes simple</li> <li>Use dataclasses for message definitions</li> <li>Include only necessary fields</li> </ul> </li> <li> <p>Handler Organization</p> <ul> <li>One handler per message type</li> <li>Clear handler naming</li> <li>Focused handler functionality</li> </ul> </li> <li> <p>Resource Management</p> <ul> <li>Use async context managers</li> <li>Proper cleanup in handlers</li> <li>Handle errors appropriately</li> </ul> </li> </ol>"},{"location":"5-minutes-to-ceylon.html#common-extensions","title":"Common Extensions","text":"<ol> <li>Add multiple message types:</li> </ol> <pre><code>@dataclass\nclass StatusMessage:\n    status: str\n\n\n@agent.on(StatusMessage)\nasync def handle_status(message: StatusMessage, sender: AgentDetail, time: int):\n    logger.info(f\"Status from {sender.name}: {message.status}\")\n</code></pre> <ol> <li>Add multiple agents:</li> </ol> <pre><code>agent1 = Worker(\"worker1\")\nagent2 = Worker(\"worker2\")\n\nasync with playground.play(workers=[agent1, agent2]) as active_playground:\n# Your code here\n</code></pre>"},{"location":"5-minutes-to-ceylon.html#troubleshooting","title":"Troubleshooting","text":"<ol> <li> <p>Messages not being received</p> <ul> <li>Check handler decorator matches message type</li> <li>Verify playground has started properly</li> <li>Ensure agent is in workers list</li> </ul> </li> <li> <p>Type errors</p> <ul> <li>Verify message class matches handler</li> <li>Check dataclass field types</li> <li>Ensure proper async/await usage</li> </ul> </li> </ol>"},{"location":"5-minutes-to-ceylon.html#next-steps","title":"Next Steps","text":"<ol> <li>Explore more complex message types</li> <li>Add multiple agents</li> <li>Implement different message patterns</li> <li>Add error handling</li> <li>Explore other Ceylon features</li> </ol>"},{"location":"5-minutes-to-ceylon.html#resources","title":"Resources","text":"<ul> <li>Ceylon Documentation: https://docs.ceylon.ai</li> <li>GitHub Repository: https://github.com/ceylon-ai/ceylon</li> </ul>"},{"location":"best-practices.html","title":"Best Practices Guide","text":""},{"location":"best-practices.html#core-design-principles","title":"Core Design Principles","text":""},{"location":"best-practices.html#1-single-responsibility","title":"1. Single Responsibility","text":"<ul> <li>Each agent should handle one primary function</li> <li>Break complex behaviors into specialized agents</li> <li>Keep message handlers focused and specific</li> </ul> <pre><code># Good\nclass DataValidator(Worker):\n    async def validate(self, data): pass\n\n\nclass DataProcessor(Worker):\n    async def process(self, data): pass\n\n\n# Avoid\nclass DataHandler(Worker):\n    async def validate_and_process(self, data): pass\n</code></pre>"},{"location":"best-practices.html#2-message-immutability","title":"2. Message Immutability","text":"<ul> <li>Define messages using dataclasses</li> <li>Never modify received messages</li> <li>Create new instances for changes</li> </ul> <pre><code>@dataclass(frozen=True)  # Enforces immutability\nclass TaskMessage:\n    id: str\n    data: Any\n    timestamp: float = field(default_factory=time.time)\n</code></pre>"},{"location":"best-practices.html#3-event-driven-architecture","title":"3. Event-Driven Architecture","text":"<ul> <li>Use decorators for message handling</li> <li>Implement asynchronous communication</li> <li>Handle events independently</li> </ul> <pre><code>class EventDrivenAgent(Worker):\n    @on(TaskMessage)\n    async def handle_task(self, msg: TaskMessage):\n        await self.process_task(msg)\n\n    @on_connect(\"*\")\n    async def handle_connection(self, topic: str, agent: AgentDetail):\n        await self.initialize_connection(agent)\n</code></pre>"},{"location":"best-practices.html#architecture-patterns","title":"Architecture Patterns","text":""},{"location":"best-practices.html#1-layered-communication","title":"1. Layered Communication","text":"<pre><code>class SystemArchitecture:\n    def __init__(self):\n        self.layers = {\n            'coordination': AdminAgent(),\n            'processing': [WorkerAgent() for _ in range(3)],\n            'storage': StorageAgent()\n        }\n</code></pre>"},{"location":"best-practices.html#2-state-management","title":"2. State Management","text":"<pre><code>class StatefulAgent(Worker):\n    def __init__(self):\n        self.state = AgentState.IDLE\n        self._transitions = {\n            AgentState.IDLE: [AgentState.PROCESSING],\n            AgentState.PROCESSING: [AgentState.COMPLETED, AgentState.ERROR]\n        }\n\n    async def transition(self, new_state: AgentState):\n        if new_state in self._transitions[self.state]:\n            self.state = new_state\n</code></pre>"},{"location":"best-practices.html#3-resource-management","title":"3. Resource Management","text":"<pre><code>class ResourceAwareAgent(Worker):\n    async def __aenter__(self):\n        await self.initialize_resources()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.cleanup_resources()\n</code></pre>"},{"location":"best-practices.html#error-handling-and-resilience","title":"Error Handling and Resilience","text":""},{"location":"best-practices.html#1-graceful-error-recovery","title":"1. Graceful Error Recovery","text":"<pre><code>class ResilientAgent(Worker):\n    async def execute_with_retry(self, task, max_retries=3):\n        for attempt in range(max_retries):\n            try:\n                return await self.process(task)\n            except Exception as e:\n                if attempt == max_retries - 1:\n                    await self.handle_failure(task, e)\n                await asyncio.sleep(2 ** attempt)\n</code></pre>"},{"location":"best-practices.html#2-circuit-breaking","title":"2. Circuit Breaking","text":"<pre><code>class CircuitBreaker:\n    def __init__(self, failure_threshold=5, reset_timeout=60):\n        self.failures = 0\n        self.threshold = failure_threshold\n        self.reset_timeout = reset_timeout\n        self.state = 'closed'\n\n    async def call(self, func, *args):\n        if self.state == 'open':\n            raise CircuitBreakerOpen()\n\n        try:\n            result = await func(*args)\n            self.failures = 0\n            return result\n        except Exception:\n            self.failures += 1\n            if self.failures &gt;= self.threshold:\n                self.state = 'open'\n                asyncio.create_task(self.reset_timer())\n            raise\n</code></pre>"},{"location":"best-practices.html#performance-optimization","title":"Performance Optimization","text":""},{"location":"best-practices.html#1-message-batching","title":"1. Message Batching","text":"<pre><code>class BatchProcessor(Worker):\n    def __init__(self, batch_size=100):\n        self.batch = []\n        self.batch_size = batch_size\n\n    async def process(self, item):\n        self.batch.append(item)\n        if len(self.batch) &gt;= self.batch_size:\n            await self.process_batch(self.batch)\n            self.batch = []\n</code></pre>"},{"location":"best-practices.html#2-resource-pooling","title":"2. Resource Pooling","text":"<pre><code>class ResourcePool:\n    def __init__(self, pool_size):\n        self.pool = asyncio.Queue(pool_size)\n        self.semaphore = asyncio.Semaphore(pool_size)\n\n    async def acquire(self):\n        async with self.semaphore:\n            return await self.pool.get()\n\n    async def release(self, resource):\n        await self.pool.put(resource)\n</code></pre>"},{"location":"best-practices.html#security-best-practices","title":"Security Best Practices","text":""},{"location":"best-practices.html#1-message-authentication","title":"1. Message Authentication","text":"<pre><code>class SecureAgent(Worker):\n    def authenticate_message(self, message, signature):\n        return hmac.verify(\n            message.content,\n            signature,\n            self.secret_key\n        )\n</code></pre>"},{"location":"best-practices.html#2-access-control","title":"2. Access Control","text":"<pre><code>class SecureWorker(Worker):\n    async def on_message(self, agent: AgentDetail, data: bytes, time: int):\n        if not self.authorize_peer(agent.id):\n            logger.warning(f\"Unauthorized message from {agent.id}\")\n            return\n        await self.process_message(data)\n</code></pre>"},{"location":"best-practices.html#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"best-practices.html#1-structured-logging","title":"1. Structured Logging","text":"<pre><code>class ObservableAgent(Worker):\n    async def log_event(self, event_type, **kwargs):\n        logger.info(\n            f\"{event_type}\",\n            agent_id=self.id,\n            timestamp=time.time(),\n            **kwargs\n        )\n</code></pre>"},{"location":"best-practices.html#2-metrics-collection","title":"2. Metrics Collection","text":"<pre><code>class MetricsCollector:\n    def __init__(self):\n        self.metrics = {\n            'messages_processed': Counter(),\n            'processing_time': Histogram(),\n            'error_rate': Gauge()\n        }\n\n    async def record(self, metric, value):\n        self.metrics[metric].record(value)\n</code></pre>"},{"location":"best-practices.html#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"best-practices.html#1-message-design","title":"1. Message Design","text":"<ul> <li>Include metadata for tracking</li> <li>Add validation methods</li> <li>Use clear naming conventions</li> </ul> <pre><code>@dataclass\nclass Message:\n    id: str = field(default_factory=uuid.uuid4)\n    timestamp: float = field(default_factory=time.time)\n    payload: Any\n    metadata: Dict = field(default_factory=dict)\n\n    def validate(self) -&gt; bool:\n        return bool(self.payload)\n</code></pre>"},{"location":"best-practices.html#2-communication-patterns","title":"2. Communication Patterns","text":"<ul> <li>Use broadcast for system-wide messages</li> <li>Direct messages for point-to-point</li> <li>Topic-based for selective communication</li> </ul> <pre><code>class CommunicationPatterns:\n    async def broadcast_update(self, update):\n        await self.broadcast_message(update)\n\n    async def direct_message(self, peer_id, message):\n        await self.send_message(peer_id, message)\n\n    async def topic_message(self, topic, message):\n        await self.publish(topic, message)\n</code></pre>"},{"location":"best-practices.html#3-state-transitions","title":"3. State Transitions","text":"<ul> <li>Define clear state machines</li> <li>Validate transitions</li> <li>Log state changes</li> </ul> <pre><code>class WorkflowAgent(Worker):\n    async def transition_state(self, new_state):\n        if new_state not in self.valid_transitions[self.current_state]:\n            raise InvalidTransition(f\"{self.current_state} -&gt; {new_state}\")\n\n        self.current_state = new_state\n        await self.log_event(\"state_change\", new_state=new_state)\n</code></pre>"},{"location":"best-practices.html#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Race Conditions</li> </ol> <ul> <li>Use synchronization primitives</li> <li>Implement proper locking</li> <li>Handle concurrent access</li> </ul> <ol> <li>Memory Leaks</li> </ol> <ul> <li>Clean up resources properly</li> <li>Implement context managers</li> <li>Monitor memory usage</li> </ul> <ol> <li>Message Overflow</li> </ol> <ul> <li>Implement backpressure</li> <li>Use flow control</li> <li>Handle queue limits</li> </ul> <ol> <li>Error Propagation</li> </ol> <ul> <li>Define error boundaries</li> <li>Implement recovery strategies</li> <li>Log error contexts</li> </ul>"},{"location":"best-practices.html#best-practices-checklist","title":"Best Practices Checklist","text":""},{"location":"best-practices.html#design","title":"Design","text":"<ul> <li> Single responsibility per agent</li> <li> Clear message contracts</li> <li> Proper state management</li> <li> Error handling strategy</li> </ul>"},{"location":"best-practices.html#implementation","title":"Implementation","text":"<ul> <li> Immutable messages</li> <li> Resource cleanup</li> <li> Proper logging</li> <li> Security measures</li> </ul>"},{"location":"best-practices.html#operation","title":"Operation","text":"<ul> <li> Monitoring setup</li> <li> Performance metrics</li> <li> Error tracking</li> <li> Resource monitoring</li> </ul>"},{"location":"best-practices.html#deployment-considerations","title":"Deployment Considerations","text":""},{"location":"best-practices.html#configuration","title":"Configuration","text":"<pre><code>class ConfigurableAgent(Worker):\n    def __init__(self, config_path: str):\n        self.config = self.load_config(config_path)\n        self.validate_config()\n</code></pre>"},{"location":"best-practices.html#resource-limits","title":"Resource Limits","text":"<pre><code>class ResourceLimits:\n    def __init__(self):\n        self.max_connections = int(os.getenv('MAX_CONNECTIONS', 100))\n        self.message_timeout = int(os.getenv('MESSAGE_TIMEOUT', 30))\n</code></pre>"},{"location":"best-practices.html#health-checks","title":"Health Checks","text":"<pre><code>class HealthCheck(Worker):\n    async def check_health(self):\n        return {\n            'status': 'healthy',\n            'connections': len(self.connections),\n            'message_rate': self.message_counter.rate()\n        }\n</code></pre>"},{"location":"core-concepts.html","title":"Ceylon Framework Core Concepts Guide","text":""},{"location":"core-concepts.html#agent-system-architecture","title":"Agent System Architecture","text":""},{"location":"core-concepts.html#admin-agent","title":"Admin Agent","text":"<p>The central coordinator in a Ceylon system.</p> <pre><code>from ceylon import Admin\n\nclass CoordinatorAdmin(Admin):\n    def __init__(self, name=\"coordinator\", port=8888):\n        super().__init__(name=name, port=port)\n</code></pre> <p>Key characteristics: - One admin per system - Manages worker connections - Coordinates task distribution - Handles system-wide state</p>"},{"location":"core-concepts.html#worker-agent","title":"Worker Agent","text":"<p>Performs specific tasks within the system.</p> <pre><code>from ceylon import Worker\n\nclass TaskWorker(Worker):\n    def __init__(self, name: str, role: str):\n        super().__init__(name=name, role=role)\n</code></pre> <p>Key characteristics: - Multiple workers per system - Specialized task execution - Reports to admin agent - Independent operation</p>"},{"location":"core-concepts.html#message-system","title":"Message System","text":""},{"location":"core-concepts.html#message-types","title":"Message Types","text":"<pre><code>from dataclasses import dataclass\nfrom typing import Any\n\n@dataclass(frozen=True)\nclass Message:\n    id: str\n    content: Any\n    timestamp: float\n</code></pre> <p>Core message principles: - Immutable data structures - Type-safe communication - Metadata inclusion - Serializable format</p>"},{"location":"core-concepts.html#message-handlers","title":"Message Handlers","text":"<pre><code>from ceylon import on, on_run, on_connect\n\nclass MessageHandling:\n    @on(MessageType)\n    async def handle_specific(self, msg: MessageType):\n        # Handle specific message type\n        pass\n\n    @on_run()\n    async def handle_run(self, inputs: bytes):\n        # Main execution loop\n        pass\n\n    @on_connect(\"*\")\n    async def handle_connection(self, topic: str, agent: AgentDetail):\n        # Connection handling\n        pass\n</code></pre>"},{"location":"core-concepts.html#communication-patterns","title":"Communication Patterns","text":""},{"location":"core-concepts.html#direct-communication","title":"Direct Communication","text":"<pre><code>class DirectCommunication(Worker):\n    async def send_to_peer(self, peer_id: str, data: Any):\n        await self.send_message(peer_id, data)\n</code></pre>"},{"location":"core-concepts.html#broadcast-communication","title":"Broadcast Communication","text":"<pre><code>class BroadcastCommunication(Admin):\n    async def notify_all(self, data: Any):\n        await self.broadcast_message(data)\n</code></pre>"},{"location":"core-concepts.html#state-management","title":"State Management","text":""},{"location":"core-concepts.html#agent-state","title":"Agent State","text":"<pre><code>from enum import Enum\n\nclass AgentState(Enum):\n    IDLE = \"idle\"\n    PROCESSING = \"processing\"\n    ERROR = \"error\"\n\nclass StateManagement(Worker):\n    def __init__(self):\n        super().__init__()\n        self.state = AgentState.IDLE\n</code></pre>"},{"location":"core-concepts.html#state-transitions","title":"State Transitions","text":"<pre><code>class StatefulAgent(Worker):\n    async def transition_state(self, new_state: AgentState):\n        old_state = self.state\n        self.state = new_state\n        await self.notify_state_change(old_state, new_state)\n</code></pre>"},{"location":"core-concepts.html#event-processing","title":"Event Processing","text":""},{"location":"core-concepts.html#event-handling","title":"Event Handling","text":"<pre><code>class EventProcessor(Worker):\n    @on(Event)\n    async def process_event(self, event: Event):\n        if self.can_handle(event):\n            await self.handle_event(event)\n        else:\n            await self.forward_event(event)\n</code></pre>"},{"location":"core-concepts.html#event-flow","title":"Event Flow","text":"<pre><code>class EventFlow(Admin):\n    async def manage_event_flow(self, event: Event):\n        # Preprocessing\n        processed_event = await self.preprocess(event)\n\n        # Distribution\n        await self.distribute_event(processed_event)\n\n        # Monitoring\n        await self.monitor_event_processing(processed_event)\n</code></pre>"},{"location":"core-concepts.html#resource-management","title":"Resource Management","text":""},{"location":"core-concepts.html#resource-lifecycle","title":"Resource Lifecycle","text":"<pre><code>class ResourceManager(Worker):\n    async def __aenter__(self):\n        await self.acquire_resources()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        await self.release_resources()\n</code></pre>"},{"location":"core-concepts.html#resource-pooling","title":"Resource Pooling","text":"<pre><code>class ResourcePool:\n    def __init__(self, size: int):\n        self.pool = asyncio.Queue(size)\n        self.in_use = set()\n\n    async def acquire(self):\n        resource = await self.pool.get()\n        self.in_use.add(resource)\n        return resource\n\n    async def release(self, resource):\n        self.in_use.remove(resource)\n        await self.pool.put(resource)\n</code></pre>"},{"location":"core-concepts.html#error-handling","title":"Error Handling","text":""},{"location":"core-concepts.html#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>class ErrorHandler(Worker):\n    async def safe_execute(self, task):\n        try:\n            return await self.execute_task(task)\n        except Exception as e:\n            await self.handle_error(task, e)\n            raise\n</code></pre>"},{"location":"core-concepts.html#retry-mechanism","title":"Retry Mechanism","text":"<pre><code>class RetryMechanism(Worker):\n    async def with_retry(self, operation, max_retries=3):\n        for attempt in range(max_retries):\n            try:\n                return await operation()\n            except Exception as e:\n                if attempt == max_retries - 1:\n                    raise\n                await asyncio.sleep(2 ** attempt)\n</code></pre>"},{"location":"core-concepts.html#system-integration","title":"System Integration","text":""},{"location":"core-concepts.html#external-service-integration","title":"External Service Integration","text":"<pre><code>class ServiceIntegrator(Worker):\n    async def interact_with_service(self, service_request):\n        # Convert to external format\n        external_request = self.convert_request(service_request)\n\n        # Make external call\n        response = await self.call_service(external_request)\n\n        # Convert response back\n        return self.convert_response(response)\n</code></pre>"},{"location":"core-concepts.html#data-flow","title":"Data Flow","text":"<pre><code>class DataFlowManager(Admin):\n    async def manage_data_flow(self, data):\n        # Input validation\n        validated_data = await self.validate(data)\n\n        # Processing\n        processed_data = await self.process(validated_data)\n\n        # Distribution\n        await self.distribute(processed_data)\n</code></pre>"},{"location":"core-concepts.html#core-utilities","title":"Core Utilities","text":""},{"location":"core-concepts.html#message-conversion","title":"Message Conversion","text":"<pre><code>class MessageConverter:\n    @staticmethod\n    def to_bytes(message: Any) -&gt; bytes:\n        return pickle.dumps(message)\n\n    @staticmethod\n    def from_bytes(data: bytes) -&gt; Any:\n        return pickle.loads(data)\n</code></pre>"},{"location":"core-concepts.html#agent-identification","title":"Agent Identification","text":"<pre><code>class AgentIdentification:\n    @staticmethod\n    def create_agent_id(name: str, role: str) -&gt; str:\n        return f\"{name}_{role}_{uuid.uuid4()}\"\n</code></pre>"},{"location":"core-concepts.html#system-lifecycle","title":"System Lifecycle","text":""},{"location":"core-concepts.html#initialization","title":"Initialization","text":"<pre><code>async def initialize_system():\n    # Create admin\n    admin = AdminAgent(port=8888)\n\n    # Create workers\n    workers = [\n        WorkerAgent(f\"worker_{i}\")\n        for i in range(3)\n    ]\n\n    # Start system\n    await admin.start_agent(b\"\", workers)\n</code></pre>"},{"location":"core-concepts.html#shutdown","title":"Shutdown","text":"<pre><code>async def shutdown_system(admin: Admin, workers: List[Worker]):\n    # Stop workers\n    for worker in workers:\n        await worker.stop()\n\n    # Stop admin\n    await admin.stop()\n</code></pre>"},{"location":"core-concepts.html#key-concepts-summary","title":"Key Concepts Summary","text":"<ol> <li> <p>Agent Hierarchy</p> <ul> <li>Admin agents coordinate</li> <li>Worker agents execute</li> <li>Clear responsibility separation</li> </ul> </li> <li> <p>Message-Based Communication</p> <ul> <li>Type-safe messages</li> <li>Asynchronous processing</li> <li>Event-driven architecture</li> </ul> </li> <li> <p>State Management</p> <ul> <li>Clear state definitions</li> <li>Controlled transitions</li> <li>State monitoring</li> </ul> </li> <li> <p>Resource Handling</p> <ul> <li>Proper initialization</li> <li>Clean cleanup</li> <li>Resource pooling</li> </ul> </li> <li> <p>Error Management</p> <ul> <li>Graceful error handling</li> <li>Retry mechanisms</li> <li>Error reporting</li> </ul> </li> </ol> <p>These core concepts provide the foundation for building robust distributed systems with Ceylon.</p>"},{"location":"playground-start.html","title":"Getting Started with Ceylon Playground","text":"<p>Ceylon is a distributed task processing framework that enables building scalable agent-based systems. This guide will walk you through creating your first Ceylon application using the Playground system.</p>"},{"location":"playground-start.html#core-concepts","title":"Core Concepts","text":"<ul> <li>Playground: A central coordinator that manages workers and task distribution</li> <li>ProcessWorker: Handles specific types of tasks</li> <li>Task: A unit of work with optional dependencies</li> <li>ProcessRequest/Response: Communication protocol between playground and workers</li> </ul>"},{"location":"playground-start.html#basic-example-text-processing-system","title":"Basic Example: Text Processing System","text":"<p>Let's create a simple system that processes text. We'll build: 1. A text processor that multiplies input 2. An aggregator that combines results 3. A playground to coordinate them</p> <pre><code>import asyncio\nfrom ceylon.processor.agent import ProcessWorker, ProcessRequest\nfrom ceylon.task.manager import Task\nfrom ceylon.task.playground import TaskProcessingPlayground\n\nclass TextProcessor(ProcessWorker):\n    \"\"\"Processes text-based tasks.\"\"\"\n\n    async def _processor(self, request: ProcessRequest, time: int):\n        data = request.data\n        return data * 5\n\nclass AggregateProcessor(ProcessWorker):\n    \"\"\"Aggregates results from multiple tasks.\"\"\"\n\n    async def _processor(self, request: ProcessRequest, time: int):\n        data = request.data or 0\n        for d in request.dependency_data.values():\n            data += d.output\n        return data\n\nasync def main():\n    # Initialize playground and workers\n    playground = TaskProcessingPlayground()\n    worker = TextProcessor(\"text_worker\", role=\"multiply\")\n    aggregate_worker = AggregateProcessor(\"aggregate_worker\", role=\"aggregate\")\n\n    async with playground.play(workers=[worker, aggregate_worker]) as active_playground:\n        # Create tasks\n        task1 = Task(\n            name=\"Process Data 1\",\n            processor=\"multiply\",\n            input_data={'data': 5}\n        )\n\n        task2 = Task(\n            name=\"Process Data 2\",\n            processor=\"multiply\",\n            input_data={'data': 10}\n        )\n\n        task3 = Task(\n            name=\"Aggregate Results\",\n            processor=\"aggregate\",\n            dependencies={task1.id, task2.id}\n        )\n\n        # Execute tasks\n        for task in [task1, task2, task3]:\n            result = await active_playground.add_and_execute_task(\n                task=task,\n                wait_for_completion=True\n            )\n            print(f\"Task: {task.name}, Result: {result.output}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"playground-start.html#key-components-explained","title":"Key Components Explained","text":""},{"location":"playground-start.html#1-processworker","title":"1. ProcessWorker","text":"<ul> <li>Base class for task processors</li> <li>Implements <code>_processor</code> method to handle specific task types</li> <li>Can access request data and metadata</li> </ul> <pre><code>class CustomWorker(ProcessWorker):\n    async def _processor(self, request: ProcessRequest, time: int) -&gt; tuple[Any, dict]:\n        result = process_data(request.data)\n        metadata = {\"processed_at\": time}\n        return result, metadata\n</code></pre>"},{"location":"playground-start.html#2-taskprocessingplayground","title":"2. TaskProcessingPlayground","text":"<ul> <li>Manages worker connections</li> <li>Coordinates task execution</li> <li>Handles dependencies between tasks</li> </ul> <pre><code>playground = TaskProcessingPlayground(name=\"my_playground\", port=8888)\nasync with playground.play(workers=[worker1, worker2]) as active_playground:\n    # Execute tasks here\n</code></pre>"},{"location":"playground-start.html#3-task","title":"3. Task","text":"<ul> <li>Represents a unit of work</li> <li>Can specify dependencies on other tasks</li> <li>Contains input data and processor type</li> </ul> <pre><code>task = Task(\n    name=\"MyTask\",\n    processor=\"worker_role\",  # Must match worker's role\n    input_data={'key': 'value'},\n    dependencies={other_task.id}  # Optional dependencies\n)\n</code></pre>"},{"location":"playground-start.html#advanced-features","title":"Advanced Features","text":""},{"location":"playground-start.html#1-task-dependencies","title":"1. Task Dependencies","text":"<p>Ceylon supports complex task dependencies:</p> <pre><code>task_a = Task(name=\"A\", processor=\"role_1\", input_data={'data': 1})\ntask_b = Task(name=\"B\", processor=\"role_2\", input_data={'data': 2})\ntask_c = Task(\n    name=\"C\",\n    processor=\"role_3\",\n    dependencies={task_a.id, task_b.id}\n)\n</code></pre>"},{"location":"playground-start.html#2-error-handling","title":"2. Error Handling","text":"<p>Workers can handle errors gracefully:</p> <pre><code>async def _processor(self, request: ProcessRequest, time: int):\n    try:\n        result = process_data(request.data)\n        return result, {\"status\": \"success\"}\n    except Exception as e:\n        raise Exception(f\"Processing failed: {str(e)}\")\n</code></pre>"},{"location":"playground-start.html#3-custom-metadata","title":"3. Custom Metadata","text":"<p>Add metadata to track processing details:</p> <pre><code>async def _processor(self, request: ProcessRequest, time: int):\n    result = process_data(request.data)\n    metadata = {\n        \"processing_time\": time,\n        \"data_size\": len(request.data),\n        \"processor_version\": \"1.0\"\n    }\n    return result, metadata\n</code></pre>"},{"location":"playground-start.html#best-practices","title":"Best Practices","text":"<ol> <li> <p>Worker Design</p> <ul> <li>Keep workers focused on single responsibilities</li> <li>Use meaningful role names</li> <li>Include proper error handling</li> </ul> </li> <li> <p>Task Management</p> <ul> <li>Break complex operations into smaller tasks</li> <li>Use clear naming conventions</li> <li>Carefully manage dependencies</li> </ul> </li> <li> <p>Resource Handling</p> <ul> <li>Use async context managers for cleanup</li> <li>Implement proper shutdown procedures</li> <li>Monitor worker health</li> </ul> </li> </ol>"},{"location":"playground-start.html#common-patterns","title":"Common Patterns","text":""},{"location":"playground-start.html#1-pipeline-processing","title":"1. Pipeline Processing","text":"<pre><code>async def create_pipeline():\n    task1 = Task(name=\"Extract\", processor=\"extractor\")\n    task2 = Task(name=\"Transform\", processor=\"transformer\",\n                 dependencies={task1.id})\n    task3 = Task(name=\"Load\", processor=\"loader\",\n                 dependencies={task2.id})\n    return [task1, task2, task3]\n</code></pre>"},{"location":"playground-start.html#2-parallel-processing","title":"2. Parallel Processing","text":"<pre><code>tasks = [\n    Task(name=f\"Process_{i}\", processor=\"worker\")\n    for i in range(5)\n]\nresults = await playground.execute_task_group(tasks)\n</code></pre>"},{"location":"playground-start.html#debugging-tips","title":"Debugging Tips","text":"<ol> <li> <p>Enable detailed logging: <pre><code>from loguru import logger\nlogger.add(\"debug.log\", level=\"DEBUG\")\n</code></pre></p> </li> <li> <p>Monitor task states: <pre><code>task_status = playground.task_manager.get_task(task_id).status\nprint(f\"Task {task_id} status: {task_status}\")\n</code></pre></p> </li> <li> <p>Check worker connections: <pre><code>connected_workers = playground.llm_agents\nprint(f\"Connected workers: {connected_workers}\")\n</code></pre></p> </li> </ol>"},{"location":"playground-start.html#next-steps","title":"Next Steps","text":"<ul> <li>Explore more complex task dependencies</li> <li>Implement custom error handling strategies</li> <li>Add monitoring and metrics collection</li> <li>Scale your system with additional workers</li> <li>Implement custom task scheduling logic</li> </ul> <p>For more information, visit the Ceylon documentation at https://ceylon.ai</p>"},{"location":"quickstart.html","title":"Getting Start Guide","text":""},{"location":"quickstart.html#installation","title":"Installation","text":"<pre><code>pip install ceylon\n</code></pre>"},{"location":"quickstart.html#core-concepts","title":"Core Concepts","text":"<ul> <li>Admin Agent: Central coordinator for the agent network</li> <li>Worker Agent: Client agents that connect to the admin</li> <li>Handlers: Functions that process messages and events</li> </ul>"},{"location":"quickstart.html#basic-usage","title":"Basic Usage","text":""},{"location":"quickstart.html#1-create-agents","title":"1. Create Agents","text":"<pre><code>from ceylon.base.agents import Admin, Worker\n\n# Create admin agent\nadmin = Admin(\n    name=\"admin\",\n    port=8888,\n    role=\"admin\"\n)\n\n# Create worker agent\nworker = Worker(\n    name=\"worker1\",\n    role=\"worker\",\n    admin_peer=\"admin\"  # Optional: specify admin to connect to\n)\n</code></pre>"},{"location":"quickstart.html#2-define-message-types","title":"2. Define Message Types","text":"<pre><code>from pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Message:\n    content: str\n</code></pre>"},{"location":"quickstart.html#3-add-message-handlers","title":"3. Add Message Handlers","text":"<pre><code>@admin.on(Message)\nasync def handle_message(data: Message, time: int, agent: AgentDetail):\n    print(f\"Received: {data.content} from {agent.name}\")\n</code></pre>"},{"location":"quickstart.html#4-add-connection-handlers","title":"4. Add Connection Handlers","text":"<pre><code>@worker.on_connect(\"*\")  # Handle all connections\nasync def on_connect(topic: str, agent: AgentDetail):\n    print(f\"Connected to {agent.name} with role {agent.role}\")\n\n\n@worker.on_connect(\"*:worker\")  # Handle specific role connections\nasync def on_worker_connect(topic: str, agent: AgentDetail):\n    print(f\"Worker connected: {agent.name}\")\n</code></pre>"},{"location":"quickstart.html#5-add-run-handlers","title":"5. Add Run Handlers","text":"<pre><code>@worker.on_run()\nasync def run_worker(inputs: bytes):\n    while True:\n        await worker.broadcast_message(Message(content=\"Hello\"))\n        await asyncio.sleep(1)\n</code></pre>"},{"location":"quickstart.html#6-start-the-network","title":"6. Start the Network","text":"<pre><code>import asyncio\n\nif __name__ == '__main__':\n    asyncio.run(admin.start_agent(workers=[worker]))\n</code></pre>"},{"location":"quickstart.html#key-features","title":"Key Features","text":"<ul> <li>Automatic message serialization/deserialization</li> <li>Built-in event handling</li> <li>Role-based connection management</li> <li>Async communication patterns</li> <li>Pattern-based message routing</li> </ul>"},{"location":"quickstart.html#best-practices","title":"Best Practices","text":"<ol> <li>Use dataclasses for message types</li> <li>Handle connection events for network awareness</li> <li>Implement error handling in message processors</li> <li>Use meaningful agent names and roles</li> <li>Structure long-running tasks in run handlers</li> </ol>"},{"location":"technology.html","title":"Technical Details","text":""},{"location":"technology.html#core-architecture","title":"Core Architecture","text":""},{"location":"technology.html#network-layer","title":"Network Layer","text":"<ul> <li> <p>libp2p Implementation</p> <ul> <li>Multi-transport: TCP, WebSocket, QUIC</li> <li>Built-in NAT traversal</li> <li>TLS and noise encryption protocols</li> <li>Yamux multiplexing</li> <li>DNS resolution support</li> </ul> </li> <li> <p>P2P Architecture</p> <ul> <li>Gossipsub protocol for pub/sub</li> <li>Rendezvous protocol for peer discovery</li> <li>Identity management with Ed25519 keys</li> <li>Mesh network topology optimization</li> <li>Configurable heartbeat intervals</li> </ul> </li> </ul>"},{"location":"technology.html#node-types","title":"Node Types","text":"<ul> <li> <p>Admin Node</p> <ul> <li>Rendezvous server capabilities</li> <li>Centralized peer registration</li> <li>Topic management</li> <li>Connection monitoring</li> </ul> </li> <li> <p>Client Node</p> <ul> <li>Auto-discovery of admin nodes</li> <li>Dynamic topic subscription</li> <li>Connection state management</li> <li>Automatic reconnection</li> </ul> </li> </ul>"},{"location":"technology.html#message-system","title":"Message System","text":"<ul> <li> <p>Message Types</p> <ul> <li>Direct peer-to-peer</li> <li>Topic-based broadcast</li> <li>System events</li> <li>Binary payload support</li> </ul> </li> <li> <p>Performance Features</p> <ul> <li>512MB maximum message size</li> <li>Configurable buffer sizes (1MB default)</li> <li>Message deduplication</li> <li>Flow control with backpressure</li> <li>Zero-copy optimization</li> </ul> </li> </ul>"},{"location":"technology.html#peer-behavior","title":"Peer Behavior","text":"<ul> <li> <p>Core Features</p> <ul> <li>Role-based access control</li> <li>Event-driven architecture</li> <li>Customizable peer modes</li> <li>Connection pooling</li> </ul> </li> <li> <p>Network Behavior</p> <ul> <li>Ping/Pong health checks</li> <li>Peer identification</li> <li>Connection metrics</li> <li>State synchronization</li> </ul> </li> </ul>"},{"location":"technology.html#implementation-details","title":"Implementation Details","text":""},{"location":"technology.html#protocol-stack","title":"Protocol Stack","text":"<ul> <li> <p>Transport Layer</p> <ul> <li>QUIC for low latency</li> <li>WebSocket for web compatibility</li> <li>TCP for fallback support</li> </ul> </li> <li> <p>Security Layer</p> <ul> <li>TLS 1.3 encryption</li> <li>Noise protocol framework</li> <li>Ed25519 signatures</li> <li>Peer authentication</li> </ul> </li> </ul>"},{"location":"technology.html#operational-features","title":"Operational Features","text":"<ul> <li> <p>Connection Management</p> <ul> <li>60-second idle timeout</li> <li>Automatic peer discovery</li> <li>Dynamic address resolution</li> <li>Multi-address support</li> </ul> </li> <li> <p>State Management</p> <ul> <li>Distributed topic registry</li> <li>Peer connection tracking</li> <li>Message history management</li> <li>Event logging</li> </ul> </li> </ul>"},{"location":"technology.html#development-status","title":"Development Status","text":""},{"location":"technology.html#production-ready","title":"Production Ready","text":"<ul> <li>Core P2P networking</li> <li>Message routing</li> <li>Python SDK</li> <li>Basic monitoring</li> </ul>"},{"location":"technology.html#in-development","title":"In Development","text":"<ul> <li>Additional language SDKs</li> <li>Web interface</li> <li>Enhanced security features</li> <li>Scalability improvements</li> </ul> <p>Copyright 2024-Present, Syigen Ltd. and Syigen Private Limited. All rights reserved.</p>"},{"location":"tutorials.html","title":"Tutorials","text":""},{"location":"tutorials.html#introduction","title":"Introduction","text":"<p>Ceylon is a distributed framework for building multi-agent systems. This guide covers core concepts, best practices, and API usage.</p>"},{"location":"tutorials.html#core-components","title":"Core Components","text":""},{"location":"tutorials.html#1-agent-types","title":"1. Agent Types","text":""},{"location":"tutorials.html#admin-agent","title":"Admin Agent","text":"<pre><code>from ceylon import Admin\n\nclass CoordinatorAgent(Admin):\n    def __init__(self, name=\"coordinator\", port=8888):\n        super().__init__(name=name, port=port)\n\n    async def on_agent_connected(self, topic: str, agent: AgentDetail):\n        # Handle new agent connections\n        pass\n</code></pre> <ul> <li>Central coordinator for the system</li> <li>Manages worker connections</li> <li>Handles task distribution</li> <li>One admin per system</li> </ul>"},{"location":"tutorials.html#worker-agent","title":"Worker Agent","text":"<pre><code>from ceylon import Worker\n\nclass TaskWorker(Worker):\n    def __init__(self, name: str):\n        super().__init__(name=name, role=\"worker\")\n\n    async def on_message(self, agent: AgentDetail, data: bytes, time: int):\n        # Process received messages\n        pass\n</code></pre> <ul> <li>Performs specific tasks</li> <li>Reports to admin agent</li> <li>Multiple workers can run simultaneously</li> </ul>"},{"location":"tutorials.html#2-message-handling","title":"2. Message Handling","text":""},{"location":"tutorials.html#event-decorators","title":"Event Decorators","text":"<pre><code>from ceylon import on, on_run, on_connect\n\nclass CustomAgent(Worker):\n    @on(MessageType)\n    async def handle_message(self, msg: MessageType, time: int, agent: AgentDetail):\n        # Process specific message type\n        pass\n\n    @on_run()\n    async def handle_run(self, inputs: bytes):\n        # Main execution loop\n        pass\n\n    @on_connect(\"*\")\n    async def handle_connection(self, topic: str, agent: AgentDetail):\n        # Handle new connections\n        pass\n</code></pre>"},{"location":"tutorials.html#message-types","title":"Message Types","text":"<p>Define message types using dataclasses: <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass TaskMessage:\n    id: int\n    data: str\n    priority: int = 1\n\n@dataclass\nclass ResultMessage:\n    task_id: int\n    result: str\n</code></pre></p>"},{"location":"tutorials.html#best-practices","title":"Best Practices","text":""},{"location":"tutorials.html#1-message-design","title":"1. Message Design","text":"<pre><code>@dataclass\nclass Message:\n    # Include metadata\n    id: str\n    timestamp: float\n\n    # Add validation\n    def validate(self) -&gt; bool:\n        return bool(self.id and self.timestamp)\n</code></pre> <ul> <li>Use dataclasses for message structure</li> <li>Include metadata for tracking</li> <li>Add validation methods</li> </ul>"},{"location":"tutorials.html#2-error-handling","title":"2. Error Handling","text":"<pre><code>class ResilientWorker(Worker):\n    async def process_task(self, task):\n        try:\n            result = await self.execute_task(task)\n            await self.send_result(result)\n        except Exception as e:\n            logger.error(f\"Task failed: {e}\")\n            await self.handle_failure(task)\n</code></pre> <ul> <li>Catch and log exceptions</li> <li>Implement retry mechanisms</li> <li>Handle cleanup properly</li> </ul>"},{"location":"tutorials.html#3-state-management","title":"3. State Management","text":"<pre><code>from enum import Enum\n\nclass AgentState(Enum):\n    IDLE = \"idle\"\n    PROCESSING = \"processing\"\n    ERROR = \"error\"\n\nclass StatefulAgent(Worker):\n    def __init__(self):\n        super().__init__()\n        self.state = AgentState.IDLE\n\n    async def transition(self, new_state: AgentState):\n        old_state = self.state\n        self.state = new_state\n        logger.info(f\"State transition: {old_state} -&gt; {new_state}\")\n</code></pre>"},{"location":"tutorials.html#4-resource-management","title":"4. Resource Management","text":"<pre><code>class ResourceAgent(Worker):\n    def __init__(self):\n        super().__init__()\n        self.resources = {}\n\n    async def cleanup(self):\n        try:\n            # Release resources\n            for resource in self.resources.values():\n                await resource.close()\n        finally:\n            await self.broadcast_shutdown()\n</code></pre>"},{"location":"tutorials.html#common-patterns","title":"Common Patterns","text":""},{"location":"tutorials.html#1-task-distribution","title":"1. Task Distribution","text":"<pre><code>class TaskDistributor(Admin):\n    def __init__(self):\n        super().__init__()\n        self.worker_loads = {}\n\n    async def assign_task(self, task):\n        available_workers = [w for w in self.worker_loads.items() \n                           if w[1] &lt; self.max_load]\n        if not available_workers:\n            raise NoAvailableWorkersError()\n\n        worker = min(available_workers, key=lambda x: x[1])[0]\n        await self.send_message(worker, task)\n        self.worker_loads[worker] += 1\n</code></pre>"},{"location":"tutorials.html#2-event-processing","title":"2. Event Processing","text":"<pre><code>class EventProcessor(Worker):\n    def __init__(self):\n        super().__init__()\n        self.handlers = {\n            'data': self.handle_data,\n            'control': self.handle_control,\n            'status': self.handle_status\n        }\n\n    async def on_message(self, agent: AgentDetail, data: bytes, time: int):\n        message = pickle.loads(data)\n        handler = self.handlers.get(message.type)\n        if handler:\n            await handler(message)\n</code></pre>"},{"location":"tutorials.html#3-pipeline-processing","title":"3. Pipeline Processing","text":"<pre><code>class PipelineStage(Worker):\n    def __init__(self, next_stage_id: str = None):\n        super().__init__()\n        self.next_stage = next_stage_id\n\n    async def process(self, data):\n        result = await self.transform(data)\n        if self.next_stage:\n            await self.send_message(self.next_stage, result)\n        return result\n</code></pre>"},{"location":"tutorials.html#practical-examples","title":"Practical Examples","text":""},{"location":"tutorials.html#1-auction-system","title":"1. Auction System","text":"<pre><code>@dataclass\nclass Bid:\n    bidder: str\n    amount: float\n\nclass AuctionManager(Admin):\n    def __init__(self, item, min_price):\n        super().__init__()\n        self.item = item\n        self.min_price = min_price\n        self.bids = []\n\n    @on(Bid)\n    async def handle_bid(self, bid: Bid, time: int, agent: AgentDetail):\n        if bid.amount &gt;= self.min_price:\n            self.bids.append(bid)\n            await self.broadcast_new_bid(bid)\n</code></pre>"},{"location":"tutorials.html#2-task-scheduler","title":"2. Task Scheduler","text":"<pre><code>@dataclass\nclass ScheduledTask:\n    id: str\n    execute_at: float\n    data: Any\n\nclass Scheduler(Admin):\n    def __init__(self):\n        super().__init__()\n        self.task_queue = []\n\n    async def schedule_task(self, task: ScheduledTask):\n        heapq.heappush(self.task_queue, (task.execute_at, task))\n        await self.check_queue()\n</code></pre>"},{"location":"tutorials.html#performance-optimization","title":"Performance Optimization","text":""},{"location":"tutorials.html#1-message-batching","title":"1. Message Batching","text":"<pre><code>class BatchProcessor(Worker):\n    def __init__(self, batch_size=100):\n        super().__init__()\n        self.batch_size = batch_size\n        self.batch = []\n\n    async def add_to_batch(self, item):\n        self.batch.append(item)\n        if len(self.batch) &gt;= self.batch_size:\n            await self.process_batch()\n</code></pre>"},{"location":"tutorials.html#2-caching","title":"2. Caching","text":"<pre><code>from functools import lru_cache\n\nclass CachedWorker(Worker):\n    def __init__(self):\n        super().__init__()\n        self.cache = {}\n\n    @lru_cache(maxsize=1000)\n    def compute_result(self, input_data):\n        return expensive_computation(input_data)\n</code></pre>"},{"location":"tutorials.html#logging-and-monitoring","title":"Logging and Monitoring","text":""},{"location":"tutorials.html#1-structured-logging","title":"1. Structured Logging","text":"<pre><code>from loguru import logger\n\nclass LoggedAgent(Worker):\n    async def on_message(self, agent: AgentDetail, data: bytes, time: int):\n        logger.info(f\"Message received\", \n                   agent_id=agent.id,\n                   message_size=len(data),\n                   timestamp=time)\n</code></pre>"},{"location":"tutorials.html#2-metrics-collection","title":"2. Metrics Collection","text":"<pre><code>class MetricsAgent(Worker):\n    def __init__(self):\n        super().__init__()\n        self.metrics = {\n            'messages_processed': 0,\n            'errors': 0,\n            'processing_time': []\n        }\n\n    async def record_metric(self, name, value):\n        self.metrics[name] = value\n        await self.report_metrics()\n</code></pre>"},{"location":"tutorials.html#security-considerations","title":"Security Considerations","text":""},{"location":"tutorials.html#message-validation","title":"Message Validation","text":"<pre><code>class SecureAgent(Worker):\n    def validate_message(self, message):\n        return (\n            self.verify_signature(message) and\n            self.check_permissions(message.sender)\n        )\n</code></pre>"},{"location":"tutorials.html#access-control","title":"Access Control","text":"<pre><code>class AuthenticatedAgent(Worker):\n    def __init__(self):\n        super().__init__()\n        self.authorized_peers = set()\n\n    async def on_message(self, agent: AgentDetail, data: bytes, time: int):\n        if agent.id not in self.authorized_peers:\n            logger.warning(f\"Unauthorized message from {agent.id}\")\n            return\n</code></pre>"},{"location":"tutorials.html#deployment-tips","title":"Deployment Tips","text":"<ol> <li>Use environment variables for configuration</li> <li>Implement proper shutdown handlers</li> <li>Monitor system resources</li> <li>Set up logging aggregation</li> <li>Implement health checks</li> </ol>"},{"location":"tutorials.html#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ol> <li>Modifying received messages</li> <li>Blocking operations in message handlers</li> <li>Missing error handling</li> <li>Inadequate logging</li> <li>Poor resource cleanup</li> </ol>"},{"location":"tutorials.html#additional-resources","title":"Additional Resources","text":"<ul> <li>Ceylon Documentation: https://docs.ceylon.ai</li> <li>GitHub Repository: https://github.com/ceylon-ai/ceylon</li> <li>API Reference: https://docs.ceylon.ai/api</li> </ul>"},{"location":"examples/auction.html","title":"Distributed Auction System","text":"<p>This tutorial demonstrates building a robust, secure distributed auction system using the Ceylon multi-agent framework. The system implements a scalable architecture with an auctioneer agent orchestrating the auction process and multiple authenticated bidder agents participating in real-time auctions.</p>"},{"location":"examples/auction.html#system-overview","title":"System Overview","text":"<p>The auction system implements: - Multiple concurrent auction support with isolation - Secure bid validation and authentication - Configurable auction rules (reserve price, minimum increment) - Fault-tolerant communication with automatic recovery - Scalable bid processing with rate limiting</p>"},{"location":"examples/auction.html#core-components","title":"Core Components","text":""},{"location":"examples/auction.html#data-models","title":"Data Models","text":"<pre><code>@dataclass\nclass Item:\n    name: str\n    starting_price: float\n    reserve_price: Optional[float] = None\n    min_increment: float = 1.0\n    auction_duration: timedelta = timedelta(minutes=5)\n\n@dataclass\nclass Bid:\n    bidder: str\n    amount: float\n    timestamp: float\n    signature: bytes  # For bid verification\n    auction_id: str\n\n@dataclass\nclass AuctionStart:\n    item: Item\n    auction_id: str\n    start_time: float\n\n@dataclass\nclass AuctionResult:\n    winner: str\n    winning_bid: float\n    auction_id: str\n    end_time: float\n\n@dataclass\nclass AuctionEnd:\n    auction_id: str\n    reason: str  # \"completed\", \"reserve_not_met\", \"cancelled\"\n</code></pre>"},{"location":"examples/auction.html#auctioneer-agent","title":"Auctioneer Agent","text":"<p>The auctioneer manages multiple concurrent auctions:</p> <pre><code>class Auctioneer(BaseAgent):\n    def __init__(self, name=\"auctioneer\", port=8888):\n        super().__init__(\n            name=name,\n            mode=PeerMode.ADMIN,\n            role=\"auctioneer\",\n            port=port\n        )\n        self.active_auctions: Dict[str, AuctionState] = {}\n        self.bid_queue = asyncio.Queue(maxsize=1000)\n        self.bidder_registry: Dict[str, BidderInfo] = {}\n</code></pre> <p>Key features: - Asynchronous bid processing with rate limiting - Automatic auction timeouts and cleanup - Bid verification and signature validation - Bidder reputation tracking - Comprehensive error handling and recovery</p>"},{"location":"examples/auction.html#bidder-agent","title":"Bidder Agent","text":"<p>Each bidder implements secure auction participation:</p> <pre><code>class Bidder(BaseAgent):\n    def __init__(self, name: str, budget: float, strategy: BiddingStrategy):\n        super().__init__(\n            name=name,\n            mode=PeerMode.CLIENT,\n            role=\"bidder\"\n        )\n        self.budget = budget\n        self.strategy = strategy\n        self.active_bids: Dict[str, float] = {}\n        self.key_pair = generate_keypair()  # For bid signing\n</code></pre> <p>Key features: - Configurable bidding strategies - Bid signing and verification - Budget enforcement and tracking - Automatic bid updates on price changes - Graceful handling of connection issues</p>"},{"location":"examples/auction.html#advanced-bidding-strategies","title":"Advanced Bidding Strategies","text":"<pre><code>class SmartBidder(Bidder):\n    async def calculate_bid(self, item: Item, auction_state: AuctionState) -&gt; float:\n        market_value = await self.estimate_market_value(item)\n        competition = len(auction_state.active_bidders)\n        time_remaining = auction_state.end_time - time.time()\n\n        if time_remaining &lt; 60:  # Last minute strategy\n            return min(self.budget, market_value * 1.1)\n\n        return min(\n            self.budget,\n            market_value * (0.8 + (0.4 * (1 - time_remaining/auction_state.duration)))\n        )\n</code></pre>"},{"location":"examples/auction.html#error-handling-and-recovery","title":"Error Handling and Recovery","text":"<pre><code>class AuctionManager:\n    async def handle_disconnection(self, bidder_id: str):\n        affected_auctions = self.find_affected_auctions(bidder_id)\n        for auction in affected_auctions:\n            if auction.status == \"pending_payment\":\n                await self.revert_auction(auction.id)\n            else:\n                await self.pause_auction(auction.id)\n                await self.notify_participants(auction.id, \"auction_paused\")\n\n    async def recover_auction_state(self, auction_id: str):\n        state = await self.load_backup_state(auction_id)\n        await self.verify_bid_sequence(state.bids)\n        await self.resume_auction(state)\n</code></pre>"},{"location":"examples/auction.html#running-the-system","title":"Running the System","text":"<ol> <li> <p>Initialize auction system with configuration: <pre><code>config = AuctionConfig(\n    min_bidders=3,\n    bid_timeout=30,\n    max_concurrent_auctions=10,\n    bid_verification_required=True\n)\nauctioneer = Auctioneer(config)\n</code></pre></p> </li> <li> <p>Create authenticated bidders: <pre><code>bidders = [\n    SmartBidder(\"Alice\", 1500.0, MarketValueStrategy()),\n    SmartBidder(\"Bob\", 1200.0, AggressiveStrategy()),\n    SmartBidder(\"Charlie\", 2000.0, ConservativeStrategy())\n]\n</code></pre></p> </li> <li> <p>Start the system with monitoring: <pre><code>async with AuctionMonitor() as monitor:\n    await auctioneer.start_agent(b\"\", bidders)\n    await monitor.track_metrics()\n</code></pre></p> </li> </ol>"},{"location":"examples/auction.html#system-architecture","title":"System Architecture","text":"<pre><code>sequenceDiagram\n    participant A as Auctioneer\n    participant B1 as Bidder1\n    participant B2 as Bidder2\n    participant B3 as Bidder3\n    participant M as Monitor\n\n    Note over A,M: Initialization Phase\n    A-&gt;&gt;M: Register System\n    B1-&gt;&gt;A: Connect(auth_token)\n    A-&gt;&gt;B1: Connection Confirmed\n    B2-&gt;&gt;A: Connect(auth_token)\n    A-&gt;&gt;B2: Connection Confirmed\n    B3-&gt;&gt;A: Connect(auth_token)\n    A-&gt;&gt;B3: Connection Confirmed\n\n    Note over A,M: Auction Start\n    A-&gt;&gt;M: Start Monitoring\n    A-&gt;&gt;B1: AuctionStart(item, rules)\n    A-&gt;&gt;B2: AuctionStart(item, rules)\n    A-&gt;&gt;B3: AuctionStart(item, rules)\n\n    Note over A,M: Active Bidding\n    B1--&gt;&gt;A: SignedBid(amount, timestamp)\n    A--&gt;&gt;M: Log Bid\n    A-&gt;&gt;B1: BidAcknowledged\n    B2--&gt;&gt;A: SignedBid(amount, timestamp)\n    A--&gt;&gt;M: Log Bid\n    A-&gt;&gt;B2: BidAcknowledged\n    B3--&gt;&gt;A: SignedBid(amount, timestamp)\n    A--&gt;&gt;M: Log Bid\n    A-&gt;&gt;B3: BidAcknowledged\n\n    Note over A,M: Auction Close\n    A-&gt;&gt;M: Finalize Metrics\n    A-&gt;&gt;B1: AuctionResult(winner, amount)\n    A-&gt;&gt;B2: AuctionResult(winner, amount)\n    A-&gt;&gt;B3: AuctionResult(winner, amount)\n    A-&gt;&gt;M: Store Results</code></pre>"},{"location":"examples/auction.html#performance-monitoring","title":"Performance Monitoring","text":"<p>The system includes built-in monitoring for: - Bid processing latency - Message queue depths - Bidder connection health - Auction completion rates - System resource utilization</p>"},{"location":"examples/auction.html#security-considerations","title":"Security Considerations","text":"<ol> <li> <p>Bid Authentication - All bids are cryptographically signed - Timestamps prevent replay attacks - Rate limiting prevents DoS attacks</p> </li> <li> <p>Data Integrity - Auction state is regularly checkpointed - Bid history is immutable and verifiable - Transaction logs for audit trails</p> </li> <li> <p>Access Control - Bidder authentication required - Role-based permissions - Resource usage quotas</p> </li> </ol>"},{"location":"examples/auction.html#scalability-features","title":"Scalability Features","text":"<ol> <li> <p>Horizontal Scaling - Multiple auctioneer instances - Load-balanced bidder connections - Distributed state management</p> </li> <li> <p>Performance Optimization - Asynchronous bid processing - Efficient state management - Connection pooling - Message batching</p> </li> </ol>"},{"location":"examples/connect-through-network.html","title":"Remote Agents","text":""},{"location":"examples/connect-through-network.html#system-components","title":"System Components","text":""},{"location":"examples/connect-through-network.html#1-server-serverpy","title":"1. Server (server.py)","text":"<pre><code>from ceylon import Admin, enable_log\nfrom loguru import logger\n\nenable_log(\"INFO\")\napp = Admin(\n    name=\"admin\",\n    port=8888,\n    role=\"admin\",\n    workspace_id=\"default\"\n)\n\n\n@app.on_run()\nasync def run_worker(inputs: bytes):\n    logger.info(f\"Worker started - {app.details().name}\")\n    while True:\n        try:\n            message = {\"type\": \"heartbeat\", \"source\": app.details().name}\n            await app.broadcast_message(message)\n            await asyncio.sleep(1)  # Prevent CPU spinning\n        except Exception as e:\n            logger.error(f\"Error in broadcast: {e}\")\n</code></pre> <p>The server implements a heartbeat system and proper error handling.</p>"},{"location":"examples/connect-through-network.html#2-worker-worker_agentpy","title":"2. Worker (worker_agent.py)","text":"<pre><code>from ceylon import Worker, AgentDetail, enable_log\nfrom loguru import logger\n\nenable_log(\"INFO\")\nworker = Worker(\n    name=\"worker\",\n    role=\"worker\",\n    workspace_id=\"default\"\n)\n\n\n@worker.on(dict)\nasync def on_message(agent: AgentDetail, data: dict, time: int):\n    try:\n        logger.info(f\"Message from {agent.name}: {data}\")\n        if data.get(\"type\") == \"heartbeat\":\n            # Handle heartbeat\n            pass\n    except Exception as e:\n        logger.error(f\"Error processing message: {e}\")\n\n\n@worker.on_connect(\"*\")\nasync def on_connect(topic: str, agent: AgentDetail):\n    logger.info(f\"Connected to {agent.name} on {topic}\")\n</code></pre> <p>Workers implement proper message handling and connection events.</p>"},{"location":"examples/connect-through-network.html#3-configuration-ceylon_network","title":"3. Configuration (.ceylon_network)","text":"<pre><code>WORKSPACE_ID=default\nWORKSPACE_IP=127.0.0.1\nWORKSPACE_PORT=8888\nWORKSPACE_BUFFER_SIZE=1024\n</code></pre>"},{"location":"examples/connect-through-network.html#setup-instructions","title":"Setup Instructions","text":"<ol> <li> <p>Start the Server:    <pre><code>python server.py\n</code></pre></p> <ul> <li>Creates .ceylon_network with auto-generated configuration</li> <li>Initializes message handlers and event system</li> </ul> </li> <li> <p>Start Worker(s):    <pre><code>python worker_agent.py\n</code></pre></p> <ul> <li>Connects using configuration from .ceylon_network</li> <li>Establishes bidirectional communication</li> </ul> </li> </ol>"},{"location":"examples/connect-through-network.html#remote-connection-setup","title":"Remote Connection Setup","text":"<ol> <li> <p>Configure Network:</p> <ul> <li>Open required ports on firewall</li> <li>Set up secure network tunneling if needed</li> <li>Update WORKSPACE_IP to server's external IP</li> </ul> </li> <li> <p>Security Considerations:</p> <ul> <li>Use environment-specific configuration files</li> <li>Implement proper access controls</li> <li>Monitor connections and traffic</li> </ul> </li> </ol>"},{"location":"examples/connect-through-network.html#network-configuration","title":"Network Configuration","text":"<ul> <li>Default settings in static_val.py:<ul> <li>Port: DEFAULT_WORKSPACE_PORT (8888)</li> <li>Buffer: DEFAULT_WORKSPACE_BUFFER_SIZE (100)</li> <li>Workspace: DEFAULT_WORKSPACE_ID</li> </ul> </li> </ul>"},{"location":"examples/connect-through-network.html#common-issues-solutions","title":"Common Issues &amp; Solutions","text":"<ol> <li> <p>Connection Issues:</p> <ul> <li>Verify network connectivity</li> <li>Check configuration file paths</li> <li>Enable DEBUG logging for troubleshooting</li> <li>Validate port accessibility</li> </ul> </li> <li> <p>System Performance:</p> <ul> <li>Monitor buffer sizes</li> <li>Implement rate limiting if needed</li> <li>Use appropriate logging levels</li> </ul> </li> </ol>"},{"location":"examples/connect-through-network.html#production-guidelines","title":"Production Guidelines","text":"<ol> <li> <p>Security:</p> <ul> <li>Use secure configuration management</li> <li>Implement authentication</li> <li>Enable network encryption</li> <li>Regular security audits</li> </ul> </li> <li> <p>Monitoring:</p> <ul> <li>Implement health checks</li> <li>Set up logging aggregation</li> <li>Monitor system metrics</li> <li>Establish alerting</li> </ul> </li> </ol>"},{"location":"examples/connect-through-network.html#system-interaction-flow","title":"System Interaction Flow","text":"<pre><code>sequenceDiagram\n    participant Admin\n    participant Network\n    participant Worker1\n    participant Worker2\n\n    Note over Admin: Start server\n    Admin-&gt;&gt;Network: Create .ceylon_network\n\n    Note over Worker1,Worker2: Workers start\n    Worker1-&gt;&gt;Network: Read config\n    Worker2-&gt;&gt;Network: Read config\n\n    Worker1-&gt;&gt;Admin: Connect\n    activate Admin\n    Admin--&gt;&gt;Worker1: Connection accepted\n    Admin-&gt;&gt;Worker1: on_agent_connected event\n    deactivate Admin\n\n    Worker2-&gt;&gt;Admin: Connect\n    activate Admin\n    Admin--&gt;&gt;Worker2: Connection accepted\n    Admin-&gt;&gt;Worker2: on_agent_connected event\n    deactivate Admin\n\n    loop Heartbeat\n        Admin-&gt;&gt;Worker1: Broadcast message\n        Admin-&gt;&gt;Worker2: Broadcast message\n        Worker1--&gt;&gt;Admin: Process message\n        Worker2--&gt;&gt;Admin: Process message\n    end\n\n    Note over Worker1: Disconnect\n    Worker1-&gt;&gt;Admin: Stop connection\n    Admin-&gt;&gt;Worker2: Update connected agents\n\n    Note over Admin: Shutdown\n    Admin-&gt;&gt;Worker2: Broadcast shutdown\n    Admin-&gt;&gt;Network: Cleanup</code></pre>"},{"location":"examples/overview.html","title":"Ceylon Architecture Approaches","text":""},{"location":"examples/overview.html#1-baseplayground-approach-base-framework","title":"1. BasePlayground Approach (Base Framework)","text":"<pre><code>graph TB\n    subgraph PlaygroundFramework[BasePlayground Framework]\n        BC[Base Coordinator]\n        WR[Worker Registry]\n        MC[Message Coordinator]\n        EC[Event Coordinator]\n    end\n\n    subgraph Workers[Worker Agents]\n        W1[Worker 1]\n        W2[Worker 2]\n        W3[Worker 3]\n    end\n\n    subgraph Extensions[Custom Extensions]\n        TM[Task Management]\n        PM[Progress Monitor]\n        GT[Goal Tracking]\n    end\n\n    BC --&gt; |Manages| WR\n    BC --&gt; |Coordinates| MC\n    BC --&gt; |Handles| EC\n\n    W1 &amp; W2 &amp; W3 --&gt; |Register with| WR\n    MC --&gt; |Routes to| Workers\n    Workers --&gt; |Events to| EC\n\n    Extensions --&gt; |Builds on| PlaygroundFramework\n\n    classDef framework fill:#e1f5fe,stroke:#01579b,stroke-width:2px;\n    classDef workers fill:#f3e5f5,stroke:#4a148c,stroke-width:2px;\n    classDef extensions fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px;</code></pre>"},{"location":"examples/overview.html#2-direct-agent-approach","title":"2. Direct Agent Approach","text":"<pre><code>graph TB\n    subgraph Agents[Independent Agents]\n        A1[Agent 1]\n        A2[Agent 2]\n        A3[Agent 3]\n        A4[Agent 4]\n    end\n\n    subgraph Communication[P2P Communication]\n        MSG[Message Exchange]\n        EP[Event Processing]\n        H[Custom Handlers]\n    end\n\n    A1 &lt;--&gt; |Direct Messages| A2\n    A2 &lt;--&gt; |Direct Messages| A3\n    A3 &lt;--&gt; |Direct Messages| A4\n    A1 &lt;--&gt; |Direct Messages| A4\n\n    Agents --&gt; MSG\n    MSG --&gt; EP\n    EP --&gt; H\n    H --&gt; Agents</code></pre>"},{"location":"examples/overview.html#key-differences","title":"Key Differences","text":""},{"location":"examples/overview.html#baseplayground-framework","title":"BasePlayground Framework","text":"<ul> <li>Foundation Layer: Provides base coordination and communication infrastructure</li> <li>Extensible Design: Can be extended with custom features like task management</li> <li>Structured Communication: Centralized message and event coordination</li> <li>Registration Management: Built-in worker registration and tracking</li> </ul>"},{"location":"examples/overview.html#direct-agent-approach","title":"Direct Agent Approach","text":"<ul> <li>Pure P2P: Direct agent-to-agent communication</li> <li>Flexible Architecture: No predefined structure</li> <li>Custom Protocols: Define your own message formats and protocols</li> <li>Independent Agents: Each agent operates autonomously</li> </ul>"},{"location":"examples/overview.html#implementation-examples","title":"Implementation Examples","text":""},{"location":"examples/overview.html#1-task-management-system-using-baseplayground","title":"1. Task Management System using BasePlayground","text":"<pre><code>class TaskPlayGround(BasePlayGround):\n    def __init__(self):\n        super().__init__()\n        self.task_manager = TaskManager()  # Custom implementation\n        self.progress_monitor = ProgressMonitor()  # Custom implementation\n\n    async def assign_tasks(self, tasks):\n        # Custom task distribution logic\n        pass\n</code></pre>"},{"location":"examples/overview.html#2-direct-agent-system","title":"2. Direct Agent System","text":"<pre><code>class DirectAgent(BaseAgent):\n    def __init__(self):\n        super().__init__()\n        self.message_handlers = {}  # Custom message handling\n        self.state_manager = StateManager()  # Custom state management\n\n    async def send_direct(self, target, message):\n        # Direct P2P communication\n        pass\n</code></pre>"},{"location":"examples/overview.html#when-to-use-each","title":"When to Use Each","text":""},{"location":"examples/overview.html#baseplayground-when","title":"BasePlayground When:","text":"<ul> <li>Need structured agent coordination</li> <li>Want to build on existing communication infrastructure</li> <li>Planning to implement custom task/work management</li> <li>Need centralized event handling</li> </ul>"},{"location":"examples/overview.html#direct-agents-when","title":"Direct Agents When:","text":"<ul> <li>Need pure P2P communication</li> <li>Want maximum flexibility</li> <li>Implementing custom protocols</li> <li>Building specialized agent behaviors</li> </ul>"},{"location":"examples/overview.html#implementation-pattern-examples","title":"Implementation Pattern Examples:","text":"<ol> <li>Meeting Scheduling</li> <li>Auction Systems</li> <li>Task Processing</li> <li>Distributed Computing</li> </ol> <p>Each example can be implemented using either approach, with the choice depending on specific requirements for structure vs flexibility.</p>"},{"location":"examples/task-manager.html","title":"Distributed Task Management System","text":""},{"location":"examples/task-manager.html#system-architecture","title":"System Architecture","text":""},{"location":"examples/task-manager.html#core-components","title":"Core Components","text":"<ol> <li> <p>Task Manager (Admin Node)    - Task distribution controller    - Worker state management    - Result aggregation</p> </li> <li> <p>Worker Nodes    - Task execution    - Progress reporting    - Skill-based routing</p> </li> <li> <p>Message Protocol    - Task assignments    - Status updates    - Completion reports</p> </li> </ol>"},{"location":"examples/task-manager.html#implementation-details","title":"Implementation Details","text":""},{"location":"examples/task-manager.html#1-data-models","title":"1. Data Models","text":"<pre><code>from dataclasses import dataclass\nfrom typing import List, Optional\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    difficulty: int\n\n    def validate(self) -&gt; bool:\n        return 1 &lt;= self.difficulty &lt;= 10\n\n@dataclass\nclass TaskAssignment:\n    task: Task\n    assigned_at: int  # Unix timestamp\n    timeout: Optional[int] = None\n\n@dataclass\nclass TaskResult:\n    task_id: int\n    worker: str\n    success: bool\n    execution_time: float\n    error_message: Optional[str] = None\n</code></pre>"},{"location":"examples/task-manager.html#2-enhanced-worker-implementation","title":"2. Enhanced Worker Implementation","text":"<pre><code>class WorkerAgent(BaseAgent):\n    def __init__(self, name: str, skill_level: int,\n                 workspace_id=DEFAULT_WORKSPACE_ID,\n                 admin_peer=\"\"):\n        self.name = name\n        self.skill_level = skill_level\n        self.has_task = False\n        self.current_task: Optional[Task] = None\n        self.task_history: List[TaskResult] = []\n\n        super().__init__(\n            name=name,\n            workspace_id=workspace_id,\n            admin_peer=admin_peer,\n            mode=PeerMode.CLIENT\n        )\n\n    @on(TaskAssignment)\n    async def handle_task(self, data: TaskAssignment, \n                         time: int, agent: AgentDetail):\n        try:\n            if self.has_task:\n                logger.warning(f\"Worker {self.name} already has task\")\n                return\n\n            self.has_task = True\n            self.current_task = data.task\n            start_time = time.time()\n\n            # Simulate work with proper error handling\n            try:\n                await asyncio.sleep(data.task.difficulty)\n                success = self.skill_level &gt;= data.task.difficulty\n            except asyncio.CancelledError:\n                success = False\n                error_msg = \"Task cancelled\"\n\n            execution_time = time.time() - start_time\n\n            result = TaskResult(\n                task_id=data.task.id,\n                worker=self.name,\n                success=success,\n                execution_time=execution_time,\n                error_message=error_msg if not success else None\n            )\n\n            self.task_history.append(result)\n            await self.broadcast(pickle.dumps(result))\n\n        except Exception as e:\n            logger.error(f\"Error in task handling: {e}\")\n            # Send failure result\n        finally:\n            self.has_task = False\n            self.current_task = None\n\n    @on_connect(\"*\")  \n    async def handle_connection(self, topic: str, \n                              agent: AgentDetail):\n        logger.info(f\"Connected to {agent.name} on {topic}\")\n</code></pre>"},{"location":"examples/task-manager.html#3-task-manager-implementation","title":"3. Task Manager Implementation","text":"<pre><code>class TaskManager(BaseAgent):\n   def __init__(self, tasks: List[Task], expected_workers: int,\n                name=\"task_manager\", port=8000):\n      super().__init__(\n         name=name,\n         port=port,\n         mode=PeerMode.ADMIN,\n         role=\"task_manager\"\n      )\n      self.tasks = tasks\n      self.expected_workers = expected_workers\n      self.task_results = []\n      self.tasks_assigned = False\n      self.worker_stats = {}\n      self.task_timeouts = {}\n\n   async def assign_tasks(self):\n      if self.tasks_assigned:\n         return\n\n      self.tasks_assigned = True\n      connected_workers = await self.get_connected_agents()\n\n      # Intelligent task distribution\n      worker_tasks = self._match_tasks_to_workers(\n         self.tasks, connected_workers)\n\n      for worker, task in worker_tasks:\n         assignment = TaskAssignment(\n            task=task,\n            assigned_at=int(time.time()),\n            timeout=task.difficulty * 2\n         )\n         await self.broadcast(pickle.dumps(assignment))\n\n         # Set timeout handler\n         self.task_timeouts[task.id] = asyncio.create_task(\n            self._handle_timeout(task.id, assignment.timeout)\n         )\n\n   async def _handle_timeout(self, task_id: int, timeout: int):\n      await asyncio.sleep(timeout)\n      if task_id not in self.completed_tasks:\n         logger.warning(f\"Task {task_id} timed out\")\n         # Implement timeout handling\n\n   def _match_tasks_to_workers(self, tasks, workers):\n      # Intelligent matching algorithm\n      matches = []\n      sorted_tasks = sorted(tasks,\n                            key=lambda t: t.difficulty,\n                            reverse=True)\n      sorted_workers = sorted(workers,\n                              key=lambda w: self._get_worker_score(w))\n\n      for task, worker in zip(sorted_tasks, sorted_workers):\n         matches.append((worker, task))\n      return matches\n\n   def _get_worker_score(self, worker):\n      stats = self.worker_stats.get(worker.name, {})\n      success_rate = stats.get('success_rate', 0.5)\n      completed_tasks = stats.get('completed_tasks', 0)\n      return success_rate * 0.7 + completed_tasks * 0.3\n\n   @on(TaskResult)\n   async def handle_result(self, data: TaskResult,\n                           time: int, agent: AgentDetail):\n      # Cancel timeout handler\n      if data.id in self.task_timeouts:\n         self.task_timeouts[data.id].cancel()\n\n      self.task_results.append(data)\n      self._update_worker_stats(data)\n\n      if len(self.task_results) == len(self.tasks):\n         await self._generate_final_report()\n         await self.end_task_management()\n\n   def _update_worker_stats(self, result: TaskResult):\n      if result.worker not in self.worker_stats:\n         self.worker_stats[result.worker] = {\n            'completed_tasks': 0,\n            'successful_tasks': 0,\n            'total_time': 0\n         }\n\n      stats = self.worker_stats[result.worker]\n      stats['completed_tasks'] += 1\n      if result.success:\n         stats['successful_tasks'] += 1\n      stats['total_time'] += result.execution_time\n      stats['success_rate'] = (stats['successful_tasks'] /\n                               stats['completed_tasks'])\n</code></pre>"},{"location":"examples/task-manager.html#system-flow-diagrams","title":"System Flow Diagrams","text":""},{"location":"examples/task-manager.html#1-normal-operation-flow","title":"1. Normal Operation Flow","text":"<pre><code>sequenceDiagram\n    participant TM as TaskManager\n    participant W1 as Worker(skill=5)\n    participant W2 as Worker(skill=8)\n\n    W1-&gt;&gt;TM: Connect\n    W2-&gt;&gt;TM: Connect\n\n    Note over TM: All workers connected\n\n    par Task Assignment\n        TM-&gt;&gt;W1: TaskAssignment(id=1, difficulty=4)\n        TM-&gt;&gt;W2: TaskAssignment(id=2, difficulty=7)\n    end\n\n    Note over W1: Processing (4s)\n    Note over W2: Processing (7s)\n\n    W1-&gt;&gt;TM: TaskResult(success=true)\n    W2-&gt;&gt;TM: TaskResult(success=true)\n\n    Note over TM: Generate Report\n\n    TM-&gt;&gt;W1: Shutdown\n    TM-&gt;&gt;W2: Shutdown</code></pre>"},{"location":"examples/task-manager.html#2-error-handling-flow","title":"2. Error Handling Flow","text":"<pre><code>sequenceDiagram\n    participant TM as TaskManager\n    participant W1 as Worker(skill=3)\n    participant W2 as Worker(skill=7)\n\n    W1-&gt;&gt;TM: Connect\n    W2-&gt;&gt;TM: Connect\n\n    TM-&gt;&gt;W1: TaskAssignment(difficulty=6)\n    TM-&gt;&gt;W2: TaskAssignment(difficulty=4)\n\n    Note over W1: Task too difficult\n    Note over W2: Processing\n\n    W1-&gt;&gt;TM: TaskResult(success=false)\n    W2-&gt;&gt;TM: TaskResult(success=true)\n\n    Note over TM: Update worker stats\n    Note over TM: Worker1 success_rate = 0%\n    Note over TM: Worker2 success_rate = 100%</code></pre>"},{"location":"examples/task-manager.html#3-timeout-handling","title":"3. Timeout Handling","text":"<pre><code>sequenceDiagram\n    participant TM as TaskManager\n    participant W1 as Worker\n\n    W1-&gt;&gt;TM: Connect\n\n    TM-&gt;&gt;W1: TaskAssignment(timeout=10s)\n\n    Note over TM: Start timeout timer\n\n    Note over W1: Task processing stuck\n\n    Note over TM: Timeout reached\n    TM-&gt;&gt;W1: Cancel task\n\n    Note over TM: Mark task as failed\n    Note over TM: Update worker stats</code></pre>"},{"location":"examples/task-manager.html#best-practices-and-error-handling","title":"Best Practices and Error Handling","text":"<ol> <li>Task Validation</li> </ol> <pre><code>def validate_task(task: Task) -&gt; bool:\n    return (1 &lt;= task.difficulty &lt;= 10 and\n            task.instructions.strip() and\n            task.id &gt; 0)\n</code></pre> <ol> <li> <p>Worker Health Monitoring <pre><code>async def check_worker_health(worker: WorkerAgent):\n    while True:\n        try:\n            await worker.ping()\n            await asyncio.sleep(30)\n        except ConnectionError:\n            logger.error(f\"Worker {worker.name} disconnected\")\n</code></pre></p> </li> <li> <p>Task Recovery <pre><code>async def recover_failed_task(task: Task, \n                            result: TaskResult):\n    if result.success:\n        return\n\n    available_workers = [w for w in workers \n                        if not w.has_task]\n    if not available_workers:\n        logger.error(\"No workers available for recovery\")\n        return\n\n    # Select best worker for recovery\n    worker = max(available_workers,\n                key=lambda w: w.skill_level)\n    await reassign_task(task, worker)\n</code></pre></p> </li> </ol>"},{"location":"examples/task-manager.html#performance-optimization","title":"Performance Optimization","text":"<ol> <li> <p>Task Batching <pre><code>async def batch_assign_tasks(tasks: List[Task], \n                           batch_size: int = 3):\n    for batch in chunks(tasks, batch_size):\n        await asyncio.gather(\n            *[assign_task(t) for t in batch]\n        )\n</code></pre></p> </li> <li> <p>Worker Scaling <pre><code>async def scale_workers(current_load: float,\n                       target_load: float = 0.7):\n    if current_load &gt; target_load:\n        await spawn_new_worker()\n    elif current_load &lt; target_load * 0.5:\n        await remove_idle_worker()\n</code></pre></p> </li> </ol>"},{"location":"examples/task-manager.html#monitoring-and-metrics","title":"Monitoring and Metrics","text":"<ol> <li> <p>System Metrics <pre><code>class SystemMetrics:\n    def __init__(self):\n        self.task_completion_times = []\n        self.worker_utilization = {}\n        self.error_counts = defaultdict(int)\n\n    async def collect_metrics(self):\n        while True:\n            self.update_metrics()\n            await asyncio.sleep(60)\n</code></pre></p> </li> <li> <p>Performance Reporting <pre><code>def generate_performance_report():\n    avg_completion_time = sum(completion_times) / len(completion_times)\n    worker_success_rates = {\n        w: stats['success_rate']\n        for w, stats in worker_stats.items()\n    }\n    return PerformanceReport(\n        avg_completion_time=avg_completion_time,\n        worker_stats=worker_success_rates,\n        error_rates=error_counts\n    )\n</code></pre></p> </li> </ol>"},{"location":"examples/time-scheduling.html","title":"Distributed Meeting Scheduler","text":""},{"location":"examples/time-scheduling.html#system-overview","title":"System Overview","text":"<p>This tutorial demonstrates building a distributed meeting scheduling system using Ceylon's agent-based architecture. The system efficiently coordinates meeting times across multiple participants while handling real-world scheduling complexities.</p>"},{"location":"examples/time-scheduling.html#what-well-build","title":"What We'll Build","text":"<p>A distributed system that: 1. Coordinates meeting schedules across multiple participants 2. Finds optimal meeting times based on availability 3. Handles scheduling conflicts and constraints 4. Manages concurrent scheduling requests 5. Provides real-time responses and updates</p>"},{"location":"examples/time-scheduling.html#key-features","title":"Key Features","text":"<ul> <li>Distributed Processing: Each participant runs as an independent agent</li> <li>Automated Negotiation: System automatically finds suitable time slots</li> <li>Conflict Resolution: Handles overlapping meetings and time conflicts</li> <li>Scalable Architecture: Easily add or remove participants</li> <li>Fault Tolerance: Handles participant disconnections and failures</li> </ul>"},{"location":"examples/time-scheduling.html#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TD\n    A[Scheduler Agent] --&gt; B[Time Slot Manager]\n    A --&gt; C[Conflict Resolver]\n    A --&gt; D[Response Aggregator]\n\n    B --&gt; E[Availability Checker]\n    C --&gt; E\n\n    P1[Participant 1] --&gt; A\n    P2[Participant 2] --&gt; A\n    P3[Participant 3] --&gt; A\n\n    subgraph \"Each Participant\"\n        CAL[Calendar Manager]\n        AH[Availability Handler]\n        COM[Communication Module]\n    end</code></pre>"},{"location":"examples/time-scheduling.html#system-components","title":"System Components","text":"<ol> <li> <p>Scheduler Agent</p> <ul> <li>Coordinates the scheduling process</li> <li>Manages participant responses</li> <li>Implements scheduling algorithms</li> </ul> </li> <li> <p>Participant Agents</p> <ul> <li>Manage individual availability</li> <li>Handle meeting requests</li> <li>Track scheduled meetings</li> </ul> </li> <li> <p>Communication Protocol</p> <ul> <li>Availability requests/responses</li> <li>Meeting confirmations</li> <li>Schedule updates</li> </ul> </li> <li> <p>Business Logic</p> <ul> <li>Time slot validation</li> <li>Conflict detection</li> <li>Priority handling</li> </ul> </li> </ol>"},{"location":"examples/time-scheduling.html#core-components","title":"Core Components","text":""},{"location":"examples/time-scheduling.html#data-models","title":"Data Models","text":"<pre><code>@dataclass\nclass TimeSlot:\n    date: str\n    start_time: int  # 24-hour format (0-23)\n    end_time: int\n\n    def __hash__(self):\n        return hash((self.date, self.start_time, self.end_time))\n\n    def validate(self) -&gt; bool:\n        return (0 &lt;= self.start_time &lt; 24 and\n                0 &lt;= self.end_time &lt;= 24 and\n                self.start_time &lt; self.end_time)\n\n@dataclass\nclass Meeting:\n    name: str\n    date: str\n    duration: int\n    minimum_participants: int\n    priority: int = 1\n\n    def validate(self) -&gt; bool:\n        return (self.duration &gt; 0 and\n                self.minimum_participants &gt; 0 and\n                self.priority &gt; 0)\n\n@dataclass\nclass SchedulingResult:\n    meeting: Meeting\n    time_slot: TimeSlot\n    participants: List[str]\n    status: str\n    error_message: Optional[str] = None\n</code></pre>"},{"location":"examples/time-scheduling.html#enhanced-participant-implementation","title":"Enhanced Participant Implementation","text":"<pre><code>class Participant(Worker):\n    def __init__(self, name: str, available_times: List[TimeSlot],\n                 admin_peer: str):\n        self.name = name\n        self.available_times = self._validate_times(available_times)\n        self.scheduled_meetings: Dict[str, TimeSlot] = {}\n        super().__init__(name=name, admin_peer=admin_peer)\n\n    def _validate_times(self, times: List[TimeSlot]) -&gt; List[TimeSlot]:\n        return [t for t in times if t.validate()]\n\n    @on(AvailabilityRequest)\n    async def handle_request(self, data: AvailabilityRequest,\n                             time: int, agent: AgentDetail):\n        try:\n            is_available = self._check_availability(\n                data.time_slot, data.time_slot.duration)\n\n            response = AvailabilityResponse(\n                participant=self.name,\n                time_slot=data.time_slot,\n                available=is_available\n            )\n            await self.broadcast_message(response)\n\n        except Exception as e:\n            logger.error(f\"Error checking availability: {e}\")\n\n    def _check_availability(self, slot: TimeSlot,\n                            duration: int) -&gt; bool:\n        # Check conflicts with scheduled meetings\n        if any(self._has_conflict(slot, scheduled_slot)\n               for scheduled_slot in self.scheduled_meetings.values()):\n            return False\n\n        # Check if slot fits in available times\n        return any(self._fits_in_slot(slot, available_slot, duration)\n                   for available_slot in self.available_times)\n\n    @staticmethod\n    def _has_conflict(slot1: TimeSlot, slot2: TimeSlot) -&gt; bool:\n        return (slot1.date == slot2.date and\n                slot1.start_time &lt; slot2.end_time and\n                slot2.start_time &lt; slot1.end_time)\n\n    @staticmethod\n    def _fits_in_slot(slot: TimeSlot, available: TimeSlot,\n                      duration: int) -&gt; bool:\n        if slot.date != available.date:\n            return False\n        latest_start = max(slot.start_time, available.start_time)\n        earliest_end = min(slot.end_time, available.end_time)\n        return earliest_end - latest_start &gt;= duration\n</code></pre>"},{"location":"examples/time-scheduling.html#enhanced-scheduler-implementation","title":"Enhanced Scheduler Implementation","text":"<pre><code>class Scheduler(Admin):\n    def __init__(self, meeting: Meeting):\n        super().__init__(name=\"scheduler\")\n        self.meeting = meeting\n        self.agreed_slots: Dict[TimeSlot, List[str]] = {}\n        self.current_slot: Optional[TimeSlot] = None\n        self.max_attempts = 10\n        self.attempt_count = 0\n\n    @on_connect(\"*\")\n    async def handle_connection(self, topic: str, agent: AgentDetail):\n        if not self.current_slot:\n            self.current_slot = TimeSlot(\n                self.meeting.date,\n                8,  # Start at 8 AM\n                8 + self.meeting.duration\n            )\n            await self._try_schedule()\n\n    async def _try_schedule(self):\n        if self.attempt_count &gt;= self.max_attempts:\n            await self._handle_scheduling_failure()\n            return\n\n        self.attempt_count += 1\n        await self.broadcast_message(\n            AvailabilityRequest(time_slot=self.current_slot)\n        )\n\n    @on(AvailabilityResponse)\n    async def handle_response(self, data: AvailabilityResponse,\n                              time: int, agent: AgentDetail):\n        if not data.available:\n            await self._try_next_slot()\n            return\n\n        slot_key = f\"{data.time_slot.date}_{data.time_slot.start_time}\"\n        if slot_key not in self.agreed_slots:\n            self.agreed_slots[slot_key] = []\n\n        if data.participant not in self.agreed_slots[slot_key]:\n            self.agreed_slots[slot_key].append(data.participant)\n\n        if len(self.agreed_slots[slot_key]) &gt;= self.meeting.minimum_participants:\n            await self._finalize_meeting(slot_key)\n\n    async def _try_next_slot(self):\n        next_slot = TimeSlot(\n            self.meeting.date,\n            self.current_slot.start_time + 1,\n            self.current_slot.start_time + 1 + self.meeting.duration\n        )\n\n        if next_slot.end_time &gt; 17:  # Don't schedule after 5 PM\n            await self._handle_scheduling_failure()\n            return\n\n        self.current_slot = next_slot\n        await self._try_schedule()\n\n    async def _finalize_meeting(self, slot_key):\n        participants = self.agreed_slots[slot_key]\n        print(f\"Meeting scheduled at {slot_key}\")\n        print(f\"Participants: {', '.join(participants)}\")\n        await self.stop()\n\n    async def _handle_scheduling_failure(self):\n        print(\"Failed to find suitable time slot\")\n        await self.stop()\n</code></pre>"},{"location":"examples/time-scheduling.html#scheduling-scenarios","title":"Scheduling Scenarios","text":""},{"location":"examples/time-scheduling.html#1-successful-first-attempt","title":"1. Successful First Attempt","text":"<pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant A as Alice\n    participant B as Bob\n    participant C as Charlie\n\n    Note over S: Meeting(duration=1, min_participants=2)\n\n    A-&gt;&gt;S: Connect\n    B-&gt;&gt;S: Connect\n    C-&gt;&gt;S: Connect\n\n    S-&gt;&gt;+A: AvailabilityRequest(8:00-9:00)\n    S-&gt;&gt;+B: AvailabilityRequest(8:00-9:00)\n    S-&gt;&gt;+C: AvailabilityRequest(8:00-9:00)\n\n    A--&gt;&gt;-S: Response(available=true)\n    B--&gt;&gt;-S: Response(available=true)\n    C--&gt;&gt;-S: Response(available=false)\n\n    Note over S: Minimum participants reached\n\n    S-&gt;&gt;A: Meeting Confirmed\n    S-&gt;&gt;B: Meeting Confirmed\n    S-&gt;&gt;C: Meeting Confirmed</code></pre>"},{"location":"examples/time-scheduling.html#2-multiple-attempts","title":"2. Multiple Attempts","text":"<pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant A as Alice\n    participant B as Bob\n\n    Note over S: Initial slot: 8:00-9:00\n\n    S-&gt;&gt;A: AvailabilityRequest(8:00)\n    S-&gt;&gt;B: AvailabilityRequest(8:00)\n\n    A--&gt;&gt;S: Response(false)\n    B--&gt;&gt;S: Response(false)\n\n    Note over S: Try next slot: 9:00-10:00\n\n    S-&gt;&gt;A: AvailabilityRequest(9:00)\n    S-&gt;&gt;B: AvailabilityRequest(9:00)\n\n    A--&gt;&gt;S: Response(true)\n    B--&gt;&gt;S: Response(true)\n\n    Note over S: Success at second attempt\n\n    S-&gt;&gt;A: Meeting Confirmed(9:00)\n    S-&gt;&gt;B: Meeting Confirmed(9:00)</code></pre>"},{"location":"examples/time-scheduling.html#3-scheduling-failure","title":"3. Scheduling Failure","text":"<pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant A as Alice\n    participant B as Bob\n\n    Note over S: max_attempts = 3\n\n    loop 3 times\n        S-&gt;&gt;A: AvailabilityRequest\n        S-&gt;&gt;B: AvailabilityRequest\n        A--&gt;&gt;S: Response(false)\n        B--&gt;&gt;S: Response(false)\n        Note over S: Try next slot\n    end\n\n    Note over S: Max attempts reached\n\n    S-&gt;&gt;A: Scheduling Failed\n    S-&gt;&gt;B: Scheduling Failed</code></pre>"},{"location":"examples/time-scheduling.html#4-conflict-resolution","title":"4. Conflict Resolution","text":"<pre><code>sequenceDiagram\n    participant S as Scheduler\n    participant P1 as Participant1\n    participant P2 as Participant2\n\n    Note over P1,P2: Both have existing meeting 10:00-11:00\n\n    S-&gt;&gt;P1: AvailabilityRequest(10:00)\n    S-&gt;&gt;P2: AvailabilityRequest(10:00)\n\n    Note over P1: Check conflicts\n    Note over P2: Check conflicts\n\n    P1--&gt;&gt;S: Response(false)\n    P2--&gt;&gt;S: Response(false)\n\n    Note over S: Adjust time slot\n\n    S-&gt;&gt;P1: AvailabilityRequest(11:00)\n    S-&gt;&gt;P2: AvailabilityRequest(11:00)\n\n    P1--&gt;&gt;S: Response(true)\n    P2--&gt;&gt;S: Response(true)</code></pre>"},{"location":"examples/time-scheduling.html#error-handling-and-recovery","title":"Error Handling and Recovery","text":"<ol> <li> <p>Participant Disconnection: <pre><code>@on_disconnect\nasync def handle_disconnection(self, agent: AgentDetail):\n    # Remove from current slot agreements\n    for participants in self.agreed_slots.values():\n        if agent.name in participants:\n            participants.remove(agent.name)\n\n    # Retry current slot if minimum participants lost\n    if self.current_slot:\n        await self._try_schedule()\n</code></pre></p> </li> <li> <p>Invalid Time Slots: <pre><code>def validate_time_slot(slot: TimeSlot) -&gt; bool:\n    if not slot.validate():\n        return False\n\n    # Business hours check (8 AM - 5 PM)\n    if not (8 &lt;= slot.start_time &lt;= 17 and\n            8 &lt;= slot.end_time &lt;= 17):\n        return False\n\n    # Weekend check\n    date_obj = datetime.strptime(slot.date, \"%Y-%m-%d\")\n    if date_obj.weekday() &gt;= 5:\n        return False\n\n    return True\n</code></pre></p> </li> <li> <p>Scheduling Timeout: <pre><code>async def schedule_with_timeout(self, timeout: int = 300):\n    try:\n        async with asyncio.timeout(timeout):\n            await self._try_schedule()\n    except asyncio.TimeoutError:\n        await self._handle_scheduling_failure()\n</code></pre></p> </li> </ol>"},{"location":"examples/time-scheduling.html#system-extensions","title":"System Extensions","text":"<ol> <li> <p>Priority-based Scheduling: <pre><code>class PriorityScheduler(Scheduler):\n    def __init__(self, meetings: List[Meeting]):\n        self.meetings = sorted(\n            meetings,\n            key=lambda m: m.priority,\n            reverse=True\n        )\n</code></pre></p> </li> <li> <p>Recurring Meetings: <pre><code>@dataclass\nclass RecurringMeeting(Meeting):\n    frequency: str  # \"daily\", \"weekly\", \"monthly\"\n    end_date: str\n\n    def generate_instances(self) -&gt; List[Meeting]:\n        instances = []\n        current = datetime.strptime(self.date, \"%Y-%m-%d\")\n        end = datetime.strptime(self.end_date, \"%Y-%m-%d\")\n\n        while current &lt;= end:\n            instances.append(Meeting(\n                name=self.name,\n                date=current.strftime(\"%Y-%m-%d\"),\n                duration=self.duration,\n                minimum_participants=self.minimum_participants\n            ))\n\n            if self.frequency == \"daily\":\n                current += timedelta(days=1)\n            elif self.frequency == \"weekly\":\n                current += timedelta(weeks=1)\n            elif self.frequency == \"monthly\":\n                current = current.replace(\n                    month=current.month % 12 + 1,\n                    year=current.year + current.month // 12\n                )\n\n        return instances\n</code></pre></p> </li> </ol>"},{"location":"examples/playground/auction.html","title":"Building a Distributed Auction System with Ceylon Playground","text":"<p>This tutorial demonstrates how to build a distributed auction system using Ceylon's TaskPlayGround functionality. The system implements a multi-agent auction where bidders compete for items using random bidding strategies.</p>"},{"location":"examples/playground/auction.html#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph Playground[Auction Playground]\n        TM[Task Manager]\n        AG[Auction Group]\n        GT[Goal Tracker]\n    end\n\n    subgraph Agents[Auction Agents]\n        B1[Bidder 1]\n        B2[Bidder 2]\n        B3[Bidder 3]\n    end\n\n    subgraph Tasks[Auction Tasks]\n        T1[Bid Task 1]\n        T2[Bid Task 2]\n        T3[Bid Task 3]\n    end\n\n    TM --&gt; AG\n    AG --&gt; GT\n    AG --&gt; |Assigns| T1\n    AG --&gt; |Assigns| T2\n    AG --&gt; |Assigns| T3\n    T1 --&gt; |Executed by| B1\n    T2 --&gt; |Executed by| B2\n    T3 --&gt; |Executed by| B3\n    GT --&gt; |Monitors| T1\n    GT --&gt; |Monitors| T2\n    GT --&gt; |Monitors| T3</code></pre>"},{"location":"examples/playground/auction.html#core-components","title":"Core Components","text":""},{"location":"examples/playground/auction.html#1-data-models","title":"1. Data Models","text":"<p>First, let's define our core data structures:</p> <pre><code>@dataclass\nclass Item:\n    name: str\n    starting_price: float\n\n@dataclass\nclass Bid:\n    bidder: str\n    amount: float\n    item_id: str\n</code></pre>"},{"location":"examples/playground/auction.html#2-auction-agent","title":"2. Auction Agent","text":"<p>The AuctionAgent class represents each bidder in the system:</p> <pre><code>class AuctionAgent(TaskExecutionAgent):\n    def __init__(self, name: str, budget: float, max_concurrent_tasks: int = 1):\n        super().__init__(\n            name=name,\n            worker_role=\"bidder\",\n            max_concurrent_tasks=max_concurrent_tasks\n        )\n        self.budget = budget\n        self.bids: Dict[str, Bid] = {}\n</code></pre> <p>Key features: - Inherits from TaskExecutionAgent for task management - Maintains a budget for bidding - Tracks bid history - Implements random bidding strategy</p>"},{"location":"examples/playground/auction.html#3-auction-setup","title":"3. Auction Setup","text":"<p>The setup_auction function configures the playground and creates tasks:</p> <pre><code>async def setup_auction(\n    item: Item,\n    bidders: List[AuctionAgent],\n    min_bids: int\n) -&gt; TaskPlayGround:\n    playground = TaskPlayGround(name=\"auction_system\")\n\n    # Create auction tasks\n    auction_tasks = [\n        TaskMessage(\n            task_id=f\"bid_{bidder.name}_{item.name}\",\n            name=f\"Place bid for {item.name}\",\n            description=f\"Submit bid for {item.name}\",\n            duration=1,\n            required_role=\"bidder\",\n            metadata={\n                'type': 'auction_bid',\n                'item': item.__dict__,\n                'item_id': item.name,\n            }\n        )\n        for bidder in bidders\n    ]\n\n    # Create task group\n    auction_group = TaskManager.create_task_group(...)\n\n    return playground, auction_group\n</code></pre>"},{"location":"examples/playground/auction.html#implementation-steps","title":"Implementation Steps","text":""},{"location":"examples/playground/auction.html#1-initialize-the-system","title":"1. Initialize the System","text":"<pre><code># Create auction item\nitem = Item(\"Rare Painting\", 1000.0)\n\n# Create bidders with budgets\nbidders = [\n    AuctionAgent(\"Alice\", 1500.0),\n    AuctionAgent(\"Bob\", 1200.0),\n    AuctionAgent(\"Charlie\", 2000.0)\n]\n</code></pre>"},{"location":"examples/playground/auction.html#2-configure-bidding-strategy","title":"2. Configure Bidding Strategy","text":"<p>The random bidding strategy uses two factors: <pre><code># Random multiplier (1.0 to 2.0) for starting price\nrandom_multiplier = 1.0 + random.random()\n\n# Random percentage of remaining budget\nbudget_percentage = random.random()\n\n# Calculate final bid\nbase_bid = item.starting_price * random_multiplier\nbudget_portion = (self.budget - base_bid) * budget_percentage\nbid_amount = min(self.budget, base_bid + budget_portion)\n</code></pre></p>"},{"location":"examples/playground/auction.html#3-run-the-auction","title":"3. Run the Auction","text":"<pre><code>async def run_auction(\n    item: Item,\n    bidders: List[AuctionAgent],\n    min_bids: int\n) -&gt; Optional[Bid]:\n\n    # Setup system\n    playground, auction_group = await setup_auction(item, bidders, min_bids)\n\n    # Run auction\n    async with playground.play(workers=bidders) as active_playground:\n        await active_playground.assign_task_groups([auction_group])\n        completed_tasks = await active_playground.wait_and_get_completed_tasks()\n\n        # Process results\n        valid_bids = [\n            Bid(**task.metadata['bid'])\n            for task in completed_tasks.values()\n            if task.completed and 'bid' in (task.metadata or {})\n        ]\n\n        # Determine winner\n        if valid_bids:\n            return max(valid_bids, key=lambda x: x.amount)\n    return None\n</code></pre>"},{"location":"examples/playground/auction.html#monitoring-and-control","title":"Monitoring and Control","text":""},{"location":"examples/playground/auction.html#1-goal-tracking","title":"1. Goal Tracking","text":"<p>The system uses a goal checker to monitor bid progress: <pre><code>def check_bid_count(task_groups: dict, completed_tasks: dict) -&gt; bool:\n    bid_count = sum(\n        1 for task in completed_tasks.values()\n        if task.completed and 'bid' in (task.metadata or {})\n    )\n    return bid_count &gt;= min_bids\n</code></pre></p>"},{"location":"examples/playground/auction.html#2-task-status-updates","title":"2. Task Status Updates","text":"<p>Monitor task completion and results: <pre><code>completed_tasks = await active_playground.wait_and_get_completed_tasks()\ntask_results = active_playground.get_task_results()\n</code></pre></p>"},{"location":"examples/playground/auction.html#error-handling","title":"Error Handling","text":"<p>The system includes comprehensive error handling:</p> <ol> <li> <p>Task Level: <pre><code>try:\n    # Process auction task\n    task.completed = True\nexcept Exception as e:\n    task.completed = False\n    task.metadata['error'] = str(e)\n</code></pre></p> </li> <li> <p>Auction Level: <pre><code>try:\n    # Run auction\n    async with playground.play(workers=bidders) as active_playground:\n        # ... auction logic ...\nexcept Exception as e:\n    logger.error(f\"Error running auction: {e}\")\n    return None\n</code></pre></p> </li> </ol>"},{"location":"examples/playground/auction.html#running-the-system","title":"Running the System","text":"<p>Complete example of running an auction:</p> <pre><code>async def main():\n    # Setup auction\n    item = Item(\"Rare Painting\", 1000.0)\n    bidders = [\n        AuctionAgent(\"Alice\", 1500.0),\n        AuctionAgent(\"Bob\", 1200.0),\n        AuctionAgent(\"Charlie\", 2000.0),\n        AuctionAgent(\"David\", 2800.0)\n    ]\n\n    # Run auction\n    winning_bid = await run_auction(\n        item=item,\n        bidders=bidders,\n        min_bids=2\n    )\n\n    # Process results\n    if winning_bid:\n        logger.info(f\"Winner: {winning_bid.bidder}\")\n        logger.info(f\"Amount: ${winning_bid.amount:.2f}\")\n    else:\n        logger.info(\"Auction failed to complete\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/playground/auction.html#system-flow","title":"System Flow","text":"<pre><code>sequenceDiagram\n    participant M as Main\n    participant P as Playground\n    participant TM as TaskManager\n    participant B as Bidders\n\n    M-&gt;&gt;P: Create Playground\n    M-&gt;&gt;TM: Create Task Group\n\n    loop For each bidder\n        TM-&gt;&gt;B: Assign Bid Task\n        B-&gt;&gt;TM: Submit Bid\n    end\n\n    TM-&gt;&gt;P: Check Goal Progress\n\n    alt Enough Bids\n        P-&gt;&gt;M: Return Results\n    else Timeout/Failure\n        P-&gt;&gt;M: Return None\n    end</code></pre>"},{"location":"examples/playground/auction.html#customization-options","title":"Customization Options","text":"<ol> <li> <p>Bidding Strategy</p> <ul> <li>Modify random factors</li> <li>Implement different bidding algorithms</li> <li>Add bid increment rules</li> </ul> </li> <li> <p>Auction Rules</p> <ul> <li>Change minimum bid requirements</li> <li>Add time limits</li> <li>Implement reserve prices</li> </ul> </li> <li> <p>Task Configuration</p> <ul> <li>Adjust task duration</li> <li>Modify concurrent task limits</li> <li>Add task dependencies</li> </ul> </li> </ol>"},{"location":"examples/playground/auction.html#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling</p> <ul> <li>Always include try-except blocks</li> <li>Log errors with context</li> <li>Implement cleanup in finally blocks</li> </ul> </li> <li> <p>Resource Management</p> <ul> <li>Use async context managers</li> <li>Clean up resources properly</li> <li>Monitor system resources</li> </ul> </li> <li> <p>Monitoring</p> <ul> <li>Log important events</li> <li>Track task progress</li> <li>Monitor system health</li> </ul> </li> </ol>"},{"location":"examples/playground/auction.html#example-output","title":"Example Output","text":"<pre><code>2025-01-26 10:15:30 | INFO | Starting auction for Rare Painting\n2025-01-26 10:15:30 | INFO | Starting price: $1000.00\n2025-01-26 10:15:30 | INFO | Minimum bids required: 2\n2025-01-26 10:15:30 | INFO | Number of bidders: 4\n\n2025-01-26 10:15:31 | INFO | Alice placed bid: $1432.50\n2025-01-26 10:15:31 | INFO | Bob placed bid: $1150.75\n2025-01-26 10:15:31 | INFO | Charlie placed bid: $1875.25\n2025-01-26 10:15:31 | INFO | David placed bid: $2234.80\n\n2025-01-26 10:15:32 | INFO | Auction completed successfully!\n2025-01-26 10:15:32 | INFO | Winner: David\n2025-01-26 10:15:32 | INFO | Winning bid: $2234.80\n</code></pre>"},{"location":"examples/playground/auction.html#conclusion","title":"Conclusion","text":"<p>This tutorial demonstrated building a distributed auction system using Ceylon's TaskPlayGround. The system provides: - Scalable multi-agent architecture - Random bidding strategies - Comprehensive monitoring - Robust error handling - Flexible customization options</p> <p>For more information, visit the Ceylon documentation at https://docs.ceylon.ai</p>"},{"location":"examples/playground/task-manager.html","title":"Building Distributed Task Processing Systems with Ceylon","text":"<p>This tutorial demonstrates how to build a distributed task processing system using Ceylon's TaskProcessingPlayground. We'll create a system where multiple workers process tasks based on their skill levels.</p>"},{"location":"examples/playground/task-manager.html#core-concepts","title":"Core Concepts","text":""},{"location":"examples/playground/task-manager.html#taskprocessingplayground","title":"TaskProcessingPlayground","text":"<ul> <li>Central coordinator for distributed task processing</li> <li>Manages task distribution and execution</li> <li>Handles worker coordination and result collection</li> </ul>"},{"location":"examples/playground/task-manager.html#processworker","title":"ProcessWorker","text":"<ul> <li>Individual processing units</li> <li>Implements specific task logic</li> <li>Can maintain internal state and configurations</li> </ul>"},{"location":"examples/playground/task-manager.html#task","title":"Task","text":"<ul> <li>Represents a unit of work</li> <li>Contains input data and processing instructions</li> <li>Can have dependencies on other tasks</li> </ul>"},{"location":"examples/playground/task-manager.html#message-passing","title":"Message Passing","text":"<p><pre><code>sequenceDiagram\n    participant TM as TaskManager\n    participant W1 as Junior(skill=3)\n    participant W2 as Intermediate(skill=6)\n    participant W3 as Senior(skill=9)\n\n    Note over TM,W3: Connection Phase\n    W1-&gt;&gt;TM: Connect\n    W2-&gt;&gt;TM: Connect\n    W3-&gt;&gt;TM: Connect\n\n    Note over TM,W3: Task Assignment Phase\n    TM-&gt;&gt;W1: TaskAssignment(Task 1, difficulty=2)\n    TM-&gt;&gt;W2: TaskAssignment(Task 2, difficulty=5)\n    TM-&gt;&gt;W3: TaskAssignment(Task 3, difficulty=8)\n\n    Note over TM,W3: Task Processing Phase\n    par Process Tasks\n        W1--&gt;&gt;TM: TaskResult(id=1, success=true)\n        W2--&gt;&gt;TM: TaskResult(id=2, success=true)\n        W3--&gt;&gt;TM: TaskResult(id=3, success=true)\n    end\n\n    Note over TM: Calculate Success Rate\n    Note over TM: End Task Management</code></pre> The diagram illustrates a distributed task management system where a central TaskManager coordinates with multiple worker agents. Each worker has a different skill level (3, 6, and 9) and can handle tasks of varying difficulty (2, 5, and 8). The workflow begins with workers connecting to the TaskManager, followed by task assignments based on availability. Workers process their assigned tasks in parallel, with success determined by whether their skill level exceeds the task's difficulty. Once all tasks are complete, the TaskManager calculates the overall success rate before shutting down.</p>"},{"location":"examples/playground/task-manager.html#implementation-guide","title":"Implementation Guide","text":""},{"location":"examples/playground/task-manager.html#1-define-your-task-structure","title":"1. Define Your Task Structure","text":"<pre><code>@dataclass\nclass WorkTask:\n    id: int\n    description: str\n    difficulty: int\n</code></pre> <p>This structure defines what information each task contains. Customize fields based on your needs.</p>"},{"location":"examples/playground/task-manager.html#2-create-a-worker-processor","title":"2. Create a Worker Processor","text":"<pre><code>class WorkerProcessor(ProcessWorker):\n    def __init__(self, name: str, skill_level: int):\n        super().__init__(name=name, role=\"worker\")\n        self.skill_level = skill_level\n\n    async def _processor(self, request: ProcessRequest, time: int) -&gt; tuple[bool, dict]:\n        task = request.data\n        await asyncio.sleep(task.difficulty)  # Simulate work\n        success = self.skill_level &gt;= task.difficulty\n        return success, {\n            \"task_id\": task.id,\n            \"worker\": self.name,\n            \"difficulty\": task.difficulty\n        }\n</code></pre> <p>Key points: - Inherit from ProcessWorker - Initialize with worker-specific attributes - Implement _processor method to handle tasks - Return results and metadata</p>"},{"location":"examples/playground/task-manager.html#3-set-up-the-playground","title":"3. Set Up the Playground","text":"<pre><code>playground = TaskProcessingPlayground(name=\"task_playground\", port=8000)\nworkers = [\n    WorkerProcessor(\"Junior\", skill_level=3),\n    WorkerProcessor(\"Intermediate\", skill_level=6),\n    WorkerProcessor(\"Senior\", skill_level=9),\n]\n</code></pre>"},{"location":"examples/playground/task-manager.html#4-create-and-execute-tasks","title":"4. Create and Execute Tasks","text":"<pre><code>async with playground.play(workers=workers) as active_playground:\n    ceylon_tasks = [\n        Task(\n            name=f\"Task {task.id}\",\n            processor=\"worker\",\n            input_data={'data': task}\n        )\n        for task in tasks\n    ]\n\n    results = []\n    for task in ceylon_tasks:\n        result = await active_playground.add_and_execute_task(\n            task=task,\n            wait_for_completion=True\n        )\n        results.append(result)\n</code></pre>"},{"location":"examples/playground/task-manager.html#advanced-features","title":"Advanced Features","text":""},{"location":"examples/playground/task-manager.html#task-dependencies","title":"Task Dependencies","text":"<pre><code>task3 = Task(\n    name=\"Aggregate Results\",\n    processor=\"aggregator\",\n    dependencies={task1.id, task2.id}\n)\n</code></pre> <p>Dependencies ensure tasks execute in the correct order.</p>"},{"location":"examples/playground/task-manager.html#error-handling","title":"Error Handling","text":"<pre><code>try:\n    result = await active_playground.add_and_execute_task(task)\n    if not result.success:\n        print(f\"Task failed: {result.error}\")\nexcept Exception as e:\n    print(f\"Error executing task: {e}\")\n</code></pre>"},{"location":"examples/playground/task-manager.html#parallel-processing","title":"Parallel Processing","text":"<p>TaskProcessingPlayground automatically handles parallel execution of independent tasks.</p>"},{"location":"examples/playground/task-manager.html#best-practices","title":"Best Practices","text":"<ol> <li> <p>Task Granularity    - Keep tasks focused and atomic    - Avoid overly complex task dependencies    - Consider breaking large tasks into smaller units</p> </li> <li> <p>Worker Design    - Make workers stateless when possible    - Handle errors gracefully in _processor    - Include relevant metadata in results</p> </li> <li> <p>Resource Management    - Use async context manager for cleanup    - Monitor worker load and task distribution    - Implement appropriate timeouts</p> </li> <li> <p>Error Handling    - Implement retries for transient failures    - Log errors with sufficient context    - Have fallback strategies for critical tasks</p> </li> </ol>"},{"location":"examples/playground/task-manager.html#example-task-pipeline","title":"Example: Task Pipeline","text":"<p>Here's an example of a more complex task pipeline:</p> <pre><code>async def create_pipeline(playground):\n    # Data preparation task\n    prep_task = Task(\n        name=\"Data Preparation\",\n        processor=\"prep_worker\",\n        input_data={'raw_data': data}\n    )\n\n    # Processing task depending on prep\n    process_task = Task(\n        name=\"Data Processing\",\n        processor=\"process_worker\",\n        dependencies={prep_task.id}\n    )\n\n    # Final aggregation\n    aggregate_task = Task(\n        name=\"Result Aggregation\",\n        processor=\"aggregator\",\n        dependencies={process_task.id}\n    )\n\n    # Execute pipeline\n    tasks = [prep_task, process_task, aggregate_task]\n    results = []\n\n    for task in tasks:\n        result = await playground.add_and_execute_task(task)\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"examples/playground/task-manager.html#debugging-tips","title":"Debugging Tips","text":"<ol> <li> <p>Enable detailed logging: <pre><code>from loguru import logger\nlogger.enable(\"ceylon\")\n</code></pre></p> </li> <li> <p>Monitor task states: <pre><code>task_status = playground.task_manager.get_task(task_id)\nprint(f\"Task status: {task_status.status}\")\n</code></pre></p> </li> <li> <p>Inspect worker connections: <pre><code>connected_workers = playground.llm_agents\nprint(f\"Connected workers: {connected_workers}\")\n</code></pre></p> </li> </ol>"},{"location":"examples/playground/task-manager.html#common-patterns","title":"Common Patterns","text":""},{"location":"examples/playground/task-manager.html#worker-pool","title":"Worker Pool","text":"<pre><code>workers = [\n    WorkerProcessor(f\"Worker-{i}\", skill_level=5)\n    for i in range(num_workers)\n]\n</code></pre>"},{"location":"examples/playground/task-manager.html#task-batching","title":"Task Batching","text":"<pre><code>task_batch = [\n    Task(name=f\"Batch-{i}\", processor=\"worker\", input_data={'batch_id': i})\n    for i in range(batch_size)\n]\nresults = await asyncio.gather(*[\n    playground.add_and_execute_task(task) for task in task_batch\n])\n</code></pre>"},{"location":"examples/playground/task-manager.html#result-aggregation","title":"Result Aggregation","text":"<pre><code>async def aggregate_results(results):\n    success_count = sum(1 for r in results if r.success)\n    success_rate = success_count / len(results)\n    return {\n        'success_rate': success_rate,\n        'total_tasks': len(results),\n        'successful_tasks': success_count\n    }\n</code></pre>"},{"location":"examples/playground/task-manager.html#conclusion","title":"Conclusion","text":"<p>Ceylon's TaskProcessingPlayground provides a robust framework for distributed task processing. Key benefits include: - Built-in task dependency management - Automatic parallel processing - Clean worker abstraction - Error handling and retries - Resource management</p> <p>Remember to: - Design tasks and workers for your specific use case - Implement proper error handling - Monitor system performance - Scale workers based on load</p> <p>For more details, refer to the Ceylon documentation and example implementations.</p>"},{"location":"examples/playground/time-scheduling.html","title":"Building a Distributed Meeting Scheduling System with Ceylon","text":"<p>This tutorial demonstrates how to build a distributed meeting scheduling system using Ceylon's BasePlayGround functionality. The system allows multiple participants to coordinate and schedule meetings based on their availability.</p>"},{"location":"examples/playground/time-scheduling.html#system-overview","title":"System Overview","text":"<p>The system implements a distributed scheduling algorithm where: - Multiple participants share their availability - Multiple meetings need to be scheduled - Each meeting has minimum participant requirements - Scheduling must respect time slots and participant constraints</p>"},{"location":"examples/playground/time-scheduling.html#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>flowchart TB\n    subgraph Playground[Scheduling Playground]\n        MT[Meeting Tracker]\n        SR[Scheduling Router]\n        PM[Progress Monitor]\n    end\n\n    subgraph Participants[Participant Agents]\n        P1[Participant 1]\n        P2[Participant 2]\n        P3[Participant 3]\n        P4[Participant 4]\n    end\n\n    subgraph Messages[Message Types]\n        AR[Availability Request]\n        AP[Availability Response]\n        MS[Meeting Scheduled]\n    end\n\n    MT --&gt; |Creates| AR\n    AR --&gt; |Sent to| Participants\n    Participants --&gt; |Responds with| AP\n    AP --&gt; |Processed by| SR\n    SR --&gt; |Creates| MS\n    MS --&gt; |Notifies| Participants\n    PM --&gt; |Monitors| SR</code></pre>"},{"location":"examples/playground/time-scheduling.html#prerequisites","title":"Prerequisites","text":"<ol> <li>Python 3.8+</li> <li>Ceylon framework</li> <li>Basic understanding of:<ul> <li>Async Python</li> <li>Distributed systems concepts</li> <li>Event-driven programming</li> </ul> </li> </ol> <pre><code>pip install ceylon loguru\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#core-components","title":"Core Components","text":""},{"location":"examples/playground/time-scheduling.html#1-data-models","title":"1. Data Models","text":"<p>First, let's define our core data structures:</p> <pre><code>@dataclass\nclass TimeSlot:\n    date: str\n    start_time: int\n    end_time: int\n\n    @property\n    def duration(self):\n        return self.end_time - self.start_time\n\n@dataclass\nclass Meeting:\n    name: str\n    date: str\n    duration: int\n    minimum_participants: int\n\n@dataclass\nclass MeetingOutput:\n    meeting_id: str\n    name: str\n    scheduled: bool\n    time_slot: Optional[TimeSlot] = None\n    participants: List[str] = field(default_factory=list)\n    error: Optional[str] = None\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#2-message-types","title":"2. Message Types","text":"<p>Define the messages that agents will exchange:</p> <pre><code>@dataclass\nclass AvailabilityRequest:\n    meeting_id: str\n    time_slot: TimeSlot\n\n@dataclass\nclass AvailabilityResponse:\n    meeting_id: str\n    participant: str\n    time_slot: TimeSlot\n    available: bool\n\n@dataclass\nclass MeetingScheduled:\n    meeting_id: str\n    time_slot: TimeSlot\n    participants: List[str]\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#3-participant-agent","title":"3. Participant Agent","text":"<p>The ParticipantAgent represents each person in the system:</p> <pre><code>class ParticipantAgent(BaseAgent):\n    def __init__(self, name: str, available_slots: List[TimeSlot]):\n        super().__init__(\n            name=name,\n            mode=PeerMode.CLIENT,\n            role=\"participant\"\n        )\n        self.available_slots = available_slots\n        self.scheduled_meetings: Dict[str, TimeSlot] = {}\n\n    @staticmethod\n    def has_overlap(slot1: TimeSlot, slot2: TimeSlot, duration: int) -&gt; bool:\n        latest_start = max(slot1.start_time, slot2.start_time)\n        earliest_end = min(slot1.end_time, slot2.end_time)\n        return earliest_end - latest_start &gt;= duration\n\n    @on(AvailabilityRequest) \n    async def handle_request(self, request: AvailabilityRequest, \n                           time: int, agent: AgentDetail):\n        # Check availability and respond\n        is_available = any(\n            self.has_overlap(slot, request.time_slot, \n                           request.time_slot.duration)\n            for slot in self.available_slots\n        )\n        response = AvailabilityResponse(\n            meeting_id=request.meeting_id,\n            participant=self.name,\n            time_slot=request.time_slot,\n            available=is_available\n        )\n        await self.broadcast_message(response)\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#4-scheduling-playground","title":"4. Scheduling Playground","text":"<p>The SchedulingPlayground coordinates the entire system:</p> <pre><code>class SchedulingPlayground(BasePlayGround):\n    def __init__(self, name=\"meeting_scheduler\", port=8888):\n        super().__init__(name=name, port=port)\n        self.meetings: Dict[str, Meeting] = {}\n        self.current_slots: Dict[str, TimeSlot] = {}\n        self.responses: Dict[str, Dict[str, List[str]]] = {}\n        self.scheduled_meetings: Dict[str, MeetingScheduled] = {}\n        self._meeting_completed_events: Dict[str, asyncio.Event] = {}\n        self._completed_meetings: Dict[str, MeetingOutput] = {}\n\n    async def schedule_meetings(self, meetings: List[Meeting], \n                              participants: List[ParticipantAgent]):\n        # Store meetings and create completion events\n        self.meetings = {str(i): meeting for i, meeting in enumerate(meetings)}\n\n        # Start scheduling process\n        async with self.play(workers=participants) as active_playground:\n            # Initialize scheduling for each meeting\n            for meeting_id, meeting in self.meetings.items():\n                await self.start_scheduling(meeting_id, meeting)\n\n            # Wait for completion\n            await self.wait_for_completion()\n            return self.get_completed_meetings()\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#implementation-steps","title":"Implementation Steps","text":""},{"location":"examples/playground/time-scheduling.html#1-initialize-the-system","title":"1. Initialize the System","text":"<pre><code># Define meetings to schedule\nmeetings = [\n    Meeting(\"Team Sync\", \"2024-07-21\", 1, 3),\n    Meeting(\"Project Review\", \"2024-07-21\", 2, 2)\n]\n\n# Create participants\nparticipants = [\n    ParticipantAgent(\n        \"Alice\",\n        [TimeSlot(\"2024-07-21\", 9, 12), \n         TimeSlot(\"2024-07-21\", 14, 17)]\n    ),\n    ParticipantAgent(\n        \"Bob\",\n        [TimeSlot(\"2024-07-21\", 10, 13), \n         TimeSlot(\"2024-07-21\", 15, 18)]\n    )\n]\n\n# Create playground\nplayground = SchedulingPlayground(port=8455)\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#2-handle-meeting-responses","title":"2. Handle Meeting Responses","text":"<pre><code>@on(AvailabilityResponse)\nasync def handle_response(self, response: AvailabilityResponse, \n                        time: int, agent: AgentDetail):\n    meeting_id = response.meeting_id\n\n    # Handle unavailable time slots\n    if not response.available:\n        await self.try_next_slot(meeting_id)\n        return\n\n    # Track responses\n    self.track_response(response)\n\n    # Try scheduling\n    if self.can_schedule(meeting_id):\n        await self.schedule_meeting(meeting_id)\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#3-schedule-meetings","title":"3. Schedule Meetings","text":"<pre><code>async def schedule_meeting(self, meeting_id: str):\n    current_slot = self.current_slots[meeting_id]\n    available_participants = self.get_available_participants(meeting_id)\n\n    scheduled = MeetingScheduled(\n        meeting_id=meeting_id,\n        time_slot=current_slot,\n        participants=available_participants\n    )\n\n    await self.broadcast_message(scheduled)\n    self._complete_meeting(meeting_id, True, scheduled)\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#system-flow","title":"System Flow","text":""},{"location":"examples/playground/time-scheduling.html#1-initialization-flow","title":"1. Initialization Flow","text":"<pre><code>sequenceDiagram\n    participant M as Main\n    participant P as Playground\n    participant PA as ParticipantAgents\n\n    M-&gt;&gt;P: Create Playground\n    M-&gt;&gt;PA: Create Participants\n    M-&gt;&gt;P: schedule_meetings(meetings, participants)\n    P-&gt;&gt;PA: Connect Participants\n\n    loop For each meeting\n        P-&gt;&gt;PA: Send AvailabilityRequest\n        PA-&gt;&gt;P: Send AvailabilityResponse\n    end</code></pre>"},{"location":"examples/playground/time-scheduling.html#2-scheduling-flow","title":"2. Scheduling Flow","text":"<pre><code>sequenceDiagram\n    participant P as Playground\n    participant PA as Participants\n\n    P-&gt;&gt;PA: AvailabilityRequest\n\n    loop Until scheduled\n        PA-&gt;&gt;P: AvailabilityResponse\n\n        alt Enough Available\n            P-&gt;&gt;PA: MeetingScheduled\n        else Try Next Slot\n            P-&gt;&gt;PA: New AvailabilityRequest\n        end\n    end</code></pre>"},{"location":"examples/playground/time-scheduling.html#advanced-features","title":"Advanced Features","text":""},{"location":"examples/playground/time-scheduling.html#1-custom-scheduling-rules","title":"1. Custom Scheduling Rules","text":"<p>Extend the scheduling logic with custom rules:</p> <pre><code>class CustomSchedulingPlayground(SchedulingPlayground):\n    def __init__(self, rules: List[SchedulingRule], **kwargs):\n        super().__init__(**kwargs)\n        self.rules = rules\n\n    async def can_schedule(self, meeting_id: str) -&gt; bool:\n        # Apply all rules\n        for rule in self.rules:\n            if not await rule.check(self, meeting_id):\n                return False\n        return True\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#2-scheduling-priorities","title":"2. Scheduling Priorities","text":"<p>Add priority handling:</p> <pre><code>@dataclass\nclass PrioritizedMeeting(Meeting):\n    priority: int = 1\n\nclass PrioritySchedulingPlayground(SchedulingPlayground):\n    def get_next_meeting(self) -&gt; Optional[str]:\n        unscheduled = self.get_unscheduled_meetings()\n        return max(unscheduled, \n                  key=lambda m: self.meetings[m].priority,\n                  default=None)\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#3-time-constraints","title":"3. Time Constraints","text":"<p>Add time constraint handling:</p> <pre><code>@dataclass\nclass TimeConstraints:\n    earliest_start: int = 9   # 9 AM\n    latest_end: int = 17      # 5 PM\n    min_gap: int = 1          # 1 hour between meetings\n\nclass ConstrainedSchedulingPlayground(SchedulingPlayground):\n    def __init__(self, constraints: TimeConstraints, **kwargs):\n        super().__init__(**kwargs)\n        self.constraints = constraints\n\n    def is_valid_slot(self, slot: TimeSlot) -&gt; bool:\n        return (slot.start_time &gt;= self.constraints.earliest_start and\n                slot.end_time &lt;= self.constraints.latest_end)\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling<ul> <li>Implement comprehensive error handling</li> <li>Use try-except blocks for message handling</li> <li>Log errors with context</li> </ul> </li> </ol> <pre><code>@on(AvailabilityResponse)\nasync def handle_response(self, response: AvailabilityResponse, \n                        time: int, agent: AgentDetail):\n    try:\n        meeting_id = response.meeting_id\n        if not self.is_valid_meeting(meeting_id):\n            logger.warning(f\"Invalid meeting ID: {meeting_id}\")\n            return\n\n        # Process response\n        await self.process_response(response)\n\n    except Exception as e:\n        logger.error(f\"Error handling response: {e}\")\n        self._complete_meeting(meeting_id, False, \n                             error=f\"Processing error: {str(e)}\")\n</code></pre> <ol> <li>Resource Management<ul> <li>Use context managers</li> <li>Clean up resources properly</li> <li>Monitor system resources</li> </ul> </li> </ol> <pre><code>async with playground.play(workers=participants) as active_playground:\n    try:\n        results = await active_playground.schedule_meetings(meetings)\n    finally:\n        await active_playground.cleanup()\n</code></pre> <ol> <li>Logging and Monitoring<ul> <li>Log important events</li> <li>Track system state</li> <li>Monitor progress</li> </ul> </li> </ol> <pre><code>def _complete_meeting(self, meeting_id: str, success: bool, \n                     scheduled: Optional[MeetingScheduled] = None,\n                     error: Optional[str] = None):\n    \"\"\"Record meeting completion status\"\"\"\n    logger.info(f\"Completing meeting {meeting_id}\")\n    logger.info(f\"Success: {success}\")\n    if error:\n        logger.error(f\"Error: {error}\")\n\n    # Record completion\n    output = MeetingOutput(\n        meeting_id=meeting_id,\n        name=self.meetings[meeting_id].name,\n        scheduled=success,\n        error=error\n    )\n\n    if success and scheduled:\n        output.time_slot = scheduled.time_slot\n        output.participants = scheduled.participants\n\n    self._completed_meetings[meeting_id] = output\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/playground/time-scheduling.html#common-issues","title":"Common Issues","text":"<ol> <li> <p>Meetings Not Scheduling</p> <ul> <li>Check participant availability</li> <li>Verify time slot constraints</li> <li>Monitor response handling</li> </ul> </li> <li> <p>System Hanging</p> <ul> <li>Check event completion</li> <li>Verify message handling</li> <li>Monitor async operations</li> </ul> </li> <li> <p>Incorrect Schedules</p> <ul> <li>Validate time slot logic</li> <li>Check overlap calculations</li> <li>Verify participant responses</li> </ul> </li> </ol>"},{"location":"examples/playground/time-scheduling.html#debug-mode","title":"Debug Mode","text":"<p>Enable detailed logging:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger.enable(\"ceylon\")\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#example-output","title":"Example Output","text":"<pre><code>2025-02-04 10:15:30 | INFO | Starting scheduling system...\n2025-02-04 10:15:30 | INFO | Participants connected: 4\n2025-02-04 10:15:30 | INFO | Scheduling 2 meetings...\n\n2025-02-04 10:15:31 | INFO | Meeting: Team Sync\n2025-02-04 10:15:31 | INFO | - Checking slot: 9:00\n2025-02-04 10:15:31 | INFO | - Available: Alice, Bob, Charlie\n2025-02-04 10:15:31 | INFO | - Scheduled successfully\n\n2025-02-04 10:15:32 | INFO | Meeting: Project Review\n2025-02-04 10:15:32 | INFO | - Checking slot: 14:00\n2025-02-04 10:15:32 | INFO | - Available: Bob, David\n2025-02-04 10:15:32 | INFO | - Scheduled successfully\n\n2025-02-04 10:15:33 | INFO | All meetings scheduled successfully!\n</code></pre>"},{"location":"examples/playground/time-scheduling.html#conclusion","title":"Conclusion","text":"<p>This tutorial demonstrated building a distributed meeting scheduling system using Ceylon's BasePlayGround. Key takeaways:</p> <ol> <li>Modular system design using playground architecture</li> <li>Effective message-based communication</li> <li>Robust error handling and resource management</li> <li>Flexible scheduling algorithms</li> <li>Comprehensive monitoring and logging</li> </ol> <p>For more information, visit: - Ceylon Documentation: https://docs.ceylon.ai - Source Code: https://github.com/ceylon-ai/ceylon</p>"},{"location":"task-agents/task-agent.html","title":"Task agent","text":"<p>I'll create a comprehensive visualization of the Ceylon distributed agent system, focusing on its key components and interactions.</p> <pre><code>graph TD\n    subgraph \"Core Components\"\n        A[Admin Agent] --&gt; MM[Message Manager]\n        A --&gt; TM[Task Manager]\n        A --&gt; CM[Connection Manager]\n\n        MM --&gt; PM[Protocol Manager]\n        TM --&gt; TS[Task Scheduler]\n        CM --&gt; AM[Agent Monitor]\n    end\n\n    subgraph \"Worker Agents\"\n        W1[Worker 1] --&gt; WH1[Message Handler]\n        W2[Worker 2] --&gt; WH2[Message Handler]\n        W3[Worker 3] --&gt; WH3[Message Handler]\n    end\n\n    subgraph \"Communication Layer\"\n        PM &lt;--&gt; P2P[P2P Network]\n        P2P &lt;--&gt; WH1\n        P2P &lt;--&gt; WH2\n        P2P &lt;--&gt; WH3\n    end\n\n    subgraph \"Task Management\"\n        TS --&gt; TQ[Task Queue]\n        TQ --&gt; TD[Task Distributor]\n        TD --&gt; W1\n        TD --&gt; W2\n        TD --&gt; W3\n    end\n\n    subgraph \"State Management\"\n        AM --&gt; AS[Agent States]\n        AS --&gt; AH[Health Monitor]\n        AH --&gt; CM\n    end\n\n    style A fill:#f9f,stroke:#333\n    style W1,W2,W3 fill:#bbf,stroke:#333\n    style P2P fill:#bfb,stroke:#333</code></pre> <p>Let me break down the key components of the Ceylon system: <pre><code>sequenceDiagram\n    participant A as Admin Agent\n    participant W1 as Worker 1\n    participant W2 as Worker 2\n    participant W3 as Worker 3\n\n    Note over A: System Initialization\n    W1-&gt;&gt;A: Connect(role=\"worker1\")\n    A-&gt;&gt;W1: Connection Confirmed\n    W2-&gt;&gt;A: Connect(role=\"worker2\")\n    A-&gt;&gt;W2: Connection Confirmed\n    W3-&gt;&gt;A: Connect(role=\"worker3\")\n    A-&gt;&gt;W3: Connection Confirmed\n\n    Note over A: Task Distribution\n    A-&gt;&gt;W1: TaskAssignment(task1)\n    A-&gt;&gt;W2: TaskAssignment(task2)\n    W1--&gt;&gt;A: TaskStatus(in_progress)\n    W2--&gt;&gt;A: TaskStatus(in_progress)\n\n    Note over W1,W2: Parallel Processing\n    W1-&gt;&gt;A: TaskComplete(task1)\n    A-&gt;&gt;W1: TaskAcknowledged\n    W2-&gt;&gt;A: TaskComplete(task2)\n    A-&gt;&gt;W2: TaskAcknowledged\n\n    Note over A: System Monitoring\n    A-&gt;&gt;W1: HealthCheck\n    W1--&gt;&gt;A: Status(healthy)\n    A-&gt;&gt;W2: HealthCheck\n    W2--&gt;&gt;A: Status(healthy)\n    A-&gt;&gt;W3: HealthCheck\n    W3--&gt;&gt;A: Status(healthy)</code></pre></p> <p>Let me explain the key components and their interactions:</p> <ol> <li> <p>Core Components:</p> <ul> <li>Admin Agent: Central coordinator that manages the entire system</li> <li>Message Manager: Handles message routing and delivery</li> <li>Task Manager: Coordinates task distribution and monitoring</li> <li>Connection Manager: Manages agent connections and health</li> </ul> </li> <li> <p>Worker Agents:</p> <ul> <li>Independent nodes that execute tasks</li> <li>Each has its own message handler</li> <li>Can operate in different roles (e.g., data_processor, reporter, system_admin)</li> <li>Maintains its own task queue and state</li> </ul> </li> <li> <p>Communication Layer:</p> <ul> <li>Built on P2P network architecture</li> <li>Uses libp2p for robust peer-to-peer communication</li> <li>Supports direct messaging and broadcasting</li> <li>Handles message serialization/deserialization</li> </ul> </li> </ol> <p>Let's look at the task management flow specifically: <pre><code>stateDiagram-v2\n    [*] --&gt; TaskCreation\n    TaskCreation --&gt; Scheduling\n\n    state Scheduling {\n        [*] --&gt; PendingAssignment\n        PendingAssignment --&gt; AssignedToWorker\n        AssignedToWorker --&gt; InProgress\n        InProgress --&gt; Completed\n        InProgress --&gt; Failed\n        Failed --&gt; PendingAssignment: Retry\n        Completed --&gt; [*]\n    }\n\n    state \"Worker States\" as WS {\n        Idle --&gt; Processing\n        Processing --&gt; Idle\n        Processing --&gt; Error\n        Error --&gt; Idle: Recovery\n    }\n\n    Scheduling --&gt; TaskMonitoring\n    TaskMonitoring --&gt; TaskCompletion\n    TaskCompletion --&gt; [*]\n\n    note right of Scheduling\n        - Worker selection\n        - Priority handling\n        - Dependency checks\n    end note\n\n    note right of WS\n        - Resource management\n        - Error handling\n        - Health monitoring\n    end note</code></pre> Key Features:</p> <ol> <li> <p>Task Management:</p> <ul> <li>Tasks are organized into groups with dependencies</li> <li>Supports priority-based scheduling</li> <li>Handles task retries and failures</li> <li>Monitors task progress and completion</li> </ul> </li> <li> <p>Worker Management:</p> <ul> <li>Role-based task assignment</li> <li>Load balancing across workers</li> <li>Health monitoring and failure detection</li> <li>Automatic task reassignment on failure</li> </ul> </li> <li> <p>State Management:</p> <ul> <li>Distributed state tracking</li> <li>Consistency maintenance</li> <li>Health monitoring</li> <li>Automatic recovery mechanisms</li> </ul> </li> </ol> <p>The system implements several important patterns:</p> <ol> <li> <p>Event-Driven Architecture:</p> <ul> <li>Uses decorators (@on, @on_connect) for event handling</li> <li>Asynchronous message processing</li> <li>Non-blocking operations</li> </ul> </li> <li> <p>Fault Tolerance:</p> <ul> <li>Automatic worker health checking</li> <li>Task retry mechanisms</li> <li>Graceful failure handling</li> <li>State recovery</li> </ul> </li> <li> <p>Scalability:</p> <ul> <li>Dynamic worker addition/removal</li> <li>Load balancing</li> <li>Distributed task processing</li> <li>Resource management</li> </ul> </li> </ol> <p>This architecture allows Ceylon to handle complex distributed workflows while maintaining reliability and scalability. The system is particularly well-suited for scenarios requiring coordinated task execution across multiple agents, such as distributed data processing, parallel computations, or orchestrated workflows.</p>"}]}